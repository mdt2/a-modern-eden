(function(e){function I(l){if(c[l])return c[l].exports;var g=c[l]={i:l,l:!1,exports:{}};return e[l].call(g.exports,g,g.exports,I),g.l=!0,g.exports}var c={};return I.m=e,I.c=c,I.d=function(e,c,l){I.o(e,c)||Object.defineProperty(e,c,{enumerable:!0,get:l})},I.r=function(e){'undefined'!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:'Module'}),Object.defineProperty(e,'__esModule',{value:!0})},I.t=function(e,c){if(1&c&&(e=I(e)),8&c)return e;if(4&c&&'object'==typeof e&&e&&e.__esModule)return e;var l=Object.create(null);if(I.r(l),Object.defineProperty(l,'default',{enumerable:!0,value:e}),2&c&&'string'!=typeof e)for(var g in e)I.d(l,g,function(I){return e[I]}.bind(null,g));return l},I.n=function(e){var c=e&&e.__esModule?function(){return e['default']}:function(){return e};return I.d(c,'a',c),c},I.o=function(e,I){return Object.prototype.hasOwnProperty.call(e,I)},I.p='',I(I.s='./src/js/index.js')})({"./node_modules/intersection-observer-polyfill/index.js":/*!**************************************************************!*\
  !*** ./node_modules/intersection-observer-polyfill/index.js ***!
  \**************************************************************//*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){'use strict';eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _src_IntersectionObserver__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/IntersectionObserver */ "./node_modules/intersection-observer-polyfill/src/IntersectionObserver.js");\n\r\n\r\nlet IntersectionObserver;\r\n\r\n// Define what implementation of IntersectionObserver\r\n// needs to be exported: existing or polyfilled.\r\nif (typeof window.IntersectionObserver === \'function\') {\r\n    // Export existing IntersectionObservers\' implementation.\r\n    IntersectionObserver = window.IntersectionObserver;\r\n} else {\r\n    // Export polyfill.\r\n    IntersectionObserver = _src_IntersectionObserver__WEBPACK_IMPORTED_MODULE_0__["default"];\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__["default"] = (IntersectionObserver);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW50ZXJzZWN0aW9uLW9ic2VydmVyLXBvbHlmaWxsL2luZGV4LmpzP2ExMmIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFzRTs7QUFFdEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDJCQUEyQixpRUFBNEI7QUFDdkQ7O0FBRWUsbUZBQW9CIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2ludGVyc2VjdGlvbi1vYnNlcnZlci1wb2x5ZmlsbC9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBJbnRlcnNlY3Rpb25PYnNlcnZlclBvbHlmaWxsIGZyb20gJy4vc3JjL0ludGVyc2VjdGlvbk9ic2VydmVyJztcclxuXHJcbmxldCBJbnRlcnNlY3Rpb25PYnNlcnZlcjtcclxuXHJcbi8vIERlZmluZSB3aGF0IGltcGxlbWVudGF0aW9uIG9mIEludGVyc2VjdGlvbk9ic2VydmVyXHJcbi8vIG5lZWRzIHRvIGJlIGV4cG9ydGVkOiBleGlzdGluZyBvciBwb2x5ZmlsbGVkLlxyXG5pZiAodHlwZW9mIHdpbmRvdy5JbnRlcnNlY3Rpb25PYnNlcnZlciA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgLy8gRXhwb3J0IGV4aXN0aW5nIEludGVyc2VjdGlvbk9ic2VydmVycycgaW1wbGVtZW50YXRpb24uXHJcbiAgICBJbnRlcnNlY3Rpb25PYnNlcnZlciA9IHdpbmRvdy5JbnRlcnNlY3Rpb25PYnNlcnZlcjtcclxufSBlbHNlIHtcclxuICAgIC8vIEV4cG9ydCBwb2x5ZmlsbC5cclxuICAgIEludGVyc2VjdGlvbk9ic2VydmVyID0gSW50ZXJzZWN0aW9uT2JzZXJ2ZXJQb2x5ZmlsbDtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgSW50ZXJzZWN0aW9uT2JzZXJ2ZXI7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/intersection-observer-polyfill/index.js\n')},"./node_modules/intersection-observer-polyfill/src/IntersectionObservation.js":/*!************************************************************************************!*\
  !*** ./node_modules/intersection-observer-polyfill/src/IntersectionObservation.js ***!
  \************************************************************************************//*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){'use strict';eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return IntersectionObservation; });\n/* harmony import */ var _shims_performance_now__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shims/performance.now */ "./node_modules/intersection-observer-polyfill/src/shims/performance.now.js");\n/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./geometry */ "./node_modules/intersection-observer-polyfill/src/geometry.js");\n/* harmony import */ var _IntersectionObserverEntry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./IntersectionObserverEntry */ "./node_modules/intersection-observer-polyfill/src/IntersectionObserverEntry.js");\n\r\n\r\n\r\n\r\nconst emptyRect = Object(_geometry__WEBPACK_IMPORTED_MODULE_1__["createRectangle"])();\r\n\r\n/**\r\n * Tells whether target is a descendant of container element\r\n * and that both of them are present in DOM.\r\n *\r\n * @param {Element} container - Container element.\r\n * @param {Element} target - Target element.\r\n * @returns {Boolean}\r\n */\r\nfunction isDetached(container, target) {\r\n    const docElement = document.documentElement;\r\n\r\n    return (\r\n        container !== docElement && !docElement.contains(container) ||\r\n        !container.contains(target)\r\n    );\r\n}\r\n\r\n/**\r\n * Computes intersection rectangle between two rectangles.\r\n *\r\n * @param {ClientRect} rootRect - Rectangle of container element.\r\n * @param {ClientRect} targetRect - Rectangle of target element.\r\n * @returns {ClientRect} Intersection rectangle.\r\n */\r\nfunction computeIntersection(rootRect, targetRect) {\r\n    const left      = Math.max(targetRect.left, rootRect.left);\r\n    const right     = Math.min(targetRect.right, rootRect.right);\r\n    const top       = Math.max(targetRect.top, rootRect.top);\r\n    const bottom    = Math.min(targetRect.bottom, rootRect.bottom);\r\n\r\n    const width = right - left;\r\n    const height = bottom - top;\r\n\r\n    return Object(_geometry__WEBPACK_IMPORTED_MODULE_1__["createRectangle"])(left, top, width, height);\r\n}\r\n\r\n/**\r\n * Finds intersection rectangle of provided elements.\r\n *\r\n * @param {Element} container - Container element.\r\n * @param {Element} target - Target element.\r\n * @param {ClientRect} targetRect - Rectangle of target element.\r\n * @param {ClientRect} containterRect - Rectangle of container element.\r\n */\r\nfunction getIntersection(container, target, containterRect, targetRect) {\r\n    let intersecRect    = targetRect,\r\n        parent          = target.parentNode,\r\n        rootReached     = false;\r\n\r\n    while (!rootReached) {\r\n        let parentRect = null;\r\n\r\n        if (parent === container || parent.nodeType !== 1) {\r\n            rootReached = true;\r\n            parentRect = containterRect;\r\n        } else if (window.getComputedStyle(parent).overflow !== \'visible\') {\r\n            parentRect = Object(_geometry__WEBPACK_IMPORTED_MODULE_1__["getRectangle"])(parent);\r\n        }\r\n\r\n        if (parentRect) {\r\n            intersecRect = computeIntersection(intersecRect, parentRect);\r\n        }\r\n\r\n        parent = parent.parentNode;\r\n    }\r\n\r\n    return intersecRect;\r\n}\r\n\r\n/**\r\n * This class is responsible for computing and keeping track of intersections\r\n * between target element and its container. It will create and queue for notification\r\n * new IntersectionObserverEntry when intersection ratio reaches new thresholded value.\r\n */\r\nclass IntersectionObservation {\r\n    /**\r\n     * Creates instance of IntersectionObservation.\r\n     *\r\n     * @param {Element} target - Element being observed.\r\n     * @param {IntersectionObserver} observer - Associated IntersectionObserver.\r\n     */\r\n    constructor(target, observer) {\r\n        this.target = target;\r\n        this.observer = observer;\r\n\r\n        this.prevTargetRect = emptyRect;\r\n        this.prevThreshold = 0;\r\n        this.prevRatio = 0;\r\n    }\r\n\r\n    /**\r\n     * Updates intersection data. Creates and queues new\r\n     * IntersectionObserverEntry if intersection threshold has changed.\r\n     *\r\n     * @param {Object} root - Element for which to compute intersection.\r\n     * @param {ClientRect} rootRect - Rectangle of root element.\r\n     * @returns {Object} An object with information about detected changes:\r\n     *  {\r\n     *      ratioChanged: boolean,\r\n     *      targetRectChanged: boolean,\r\n     *      thresholdChanged: boolean\r\n     *  }\r\n     */\r\n    updateIntersection(root, rootRect) {\r\n        let targetRect          = Object(_geometry__WEBPACK_IMPORTED_MODULE_1__["getRectangle"])(this.target),\r\n            intersection        = this.getIntersectionData(root, rootRect, targetRect),\r\n            threshold           = +intersection.exists,\r\n            ratioChanged        = intersection.ratio !== this.prevRatio,\r\n            targetRectChanged   = !Object(_geometry__WEBPACK_IMPORTED_MODULE_1__["isEqual"])(targetRect, this.prevTargetRect),\r\n            thresholdChanged;\r\n\r\n        // Find thresholds\' index if intersection\r\n        // and target rectangles are not empty.\r\n        if (intersection.exists && !Object(_geometry__WEBPACK_IMPORTED_MODULE_1__["isEmpty"])(targetRect)) {\r\n            threshold = this.observer.getThresholdGreaterThan(intersection.ratio);\r\n        }\r\n\r\n        thresholdChanged = threshold !== this.prevThreshold;\r\n\r\n        // Update cached properties.\r\n        this.prevTargetRect = targetRect;\r\n        this.prevThreshold = threshold;\r\n        this.prevRatio = intersection.ratio;\r\n\r\n        // Create an empty rectangle if there is no intersection.\r\n        if (!intersection.exists) {\r\n            intersection.ratio = 0;\r\n            intersection.rect = emptyRect;\r\n        }\r\n\r\n        // Create and queue new entry if threshold has changed.\r\n        if (thresholdChanged) {\r\n            const entry = new _IntersectionObserverEntry__WEBPACK_IMPORTED_MODULE_2__["default"](\r\n                this.target,\r\n                targetRect,\r\n                intersection.rect,\r\n                intersection.ratio,\r\n                rootRect,\r\n                Object(_shims_performance_now__WEBPACK_IMPORTED_MODULE_0__["default"])()\r\n            );\r\n\r\n            this.observer.queueEntry(entry);\r\n        }\r\n\r\n        return {ratioChanged, thresholdChanged, targetRectChanged};\r\n    }\r\n\r\n    /**\r\n     * Computes intersection data.\r\n     *\r\n     * @param {Element} container - Container element.\r\n     * @param {ClientRect} [containterRect]\r\n     * @param {ClientRect} [targetRect]\r\n     * @returns {Object}\r\n     */\r\n    getIntersectionData(container, containterRect, targetRect) {\r\n        const target = this.target;\r\n\r\n        if (!targetRect) {\r\n            targetRect = Object(_geometry__WEBPACK_IMPORTED_MODULE_1__["getRectangle"])(this.target);\r\n        }\r\n\r\n        if (!containterRect) {\r\n            containterRect = Object(_geometry__WEBPACK_IMPORTED_MODULE_1__["getRectangle"])(container);\r\n        }\r\n\r\n        let detached        = isDetached(container, target),\r\n            intersecRect    = !detached ? getIntersection(container, target, containterRect, targetRect) : emptyRect,\r\n            intersects      = !detached && intersecRect.width >= 0 && intersecRect.height >= 0,\r\n            intersecRatio   = Object(_geometry__WEBPACK_IMPORTED_MODULE_1__["getArea"])(intersecRect) / Object(_geometry__WEBPACK_IMPORTED_MODULE_1__["getArea"])(targetRect) || 0;\r\n\r\n        return {\r\n            rect: intersecRect,\r\n            ratio: intersecRatio,\r\n            exists: intersects\r\n        };\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW50ZXJzZWN0aW9uLW9ic2VydmVyLXBvbHlmaWxsL3NyYy9JbnRlcnNlY3Rpb25PYnNlcnZhdGlvbi5qcz9lOTAzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBMEM7QUFDMkM7QUFDakI7O0FBRXBFLGtCQUFrQixpRUFBZTs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxXQUFXO0FBQ3RCLGFBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxXQUFXLGlFQUFlO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsV0FBVztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHlCQUF5Qiw4REFBWTtBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLHFCQUFxQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFdBQVc7QUFDMUIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsOERBQVk7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHlEQUFPO0FBQzFDOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0MseURBQU87QUFDM0M7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEIsa0VBQXlCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0VBQUc7QUFDbkI7O0FBRUE7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsV0FBVztBQUMxQixlQUFlLFdBQVc7QUFDMUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5Qiw4REFBWTtBQUNyQzs7QUFFQTtBQUNBLDZCQUE2Qiw4REFBWTtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIseURBQU8saUJBQWlCLHlEQUFPOztBQUU3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9pbnRlcnNlY3Rpb24tb2JzZXJ2ZXItcG9seWZpbGwvc3JjL0ludGVyc2VjdGlvbk9ic2VydmF0aW9uLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG5vdyBmcm9tICcuL3NoaW1zL3BlcmZvcm1hbmNlLm5vdyc7XHJcbmltcG9ydCB7Z2V0QXJlYSwgZ2V0UmVjdGFuZ2xlLCBjcmVhdGVSZWN0YW5nbGUsIGlzRW1wdHksIGlzRXF1YWx9ICBmcm9tICcuL2dlb21ldHJ5JztcclxuaW1wb3J0IEludGVyc2VjdGlvbk9ic2VydmVyRW50cnkgZnJvbSAnLi9JbnRlcnNlY3Rpb25PYnNlcnZlckVudHJ5JztcclxuXHJcbmNvbnN0IGVtcHR5UmVjdCA9IGNyZWF0ZVJlY3RhbmdsZSgpO1xyXG5cclxuLyoqXHJcbiAqIFRlbGxzIHdoZXRoZXIgdGFyZ2V0IGlzIGEgZGVzY2VuZGFudCBvZiBjb250YWluZXIgZWxlbWVudFxyXG4gKiBhbmQgdGhhdCBib3RoIG9mIHRoZW0gYXJlIHByZXNlbnQgaW4gRE9NLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRhaW5lciAtIENvbnRhaW5lciBlbGVtZW50LlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIFRhcmdldCBlbGVtZW50LlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cclxuICovXHJcbmZ1bmN0aW9uIGlzRGV0YWNoZWQoY29udGFpbmVyLCB0YXJnZXQpIHtcclxuICAgIGNvbnN0IGRvY0VsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICBjb250YWluZXIgIT09IGRvY0VsZW1lbnQgJiYgIWRvY0VsZW1lbnQuY29udGFpbnMoY29udGFpbmVyKSB8fFxyXG4gICAgICAgICFjb250YWluZXIuY29udGFpbnModGFyZ2V0KVxyXG4gICAgKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbXB1dGVzIGludGVyc2VjdGlvbiByZWN0YW5nbGUgYmV0d2VlbiB0d28gcmVjdGFuZ2xlcy5cclxuICpcclxuICogQHBhcmFtIHtDbGllbnRSZWN0fSByb290UmVjdCAtIFJlY3RhbmdsZSBvZiBjb250YWluZXIgZWxlbWVudC5cclxuICogQHBhcmFtIHtDbGllbnRSZWN0fSB0YXJnZXRSZWN0IC0gUmVjdGFuZ2xlIG9mIHRhcmdldCBlbGVtZW50LlxyXG4gKiBAcmV0dXJucyB7Q2xpZW50UmVjdH0gSW50ZXJzZWN0aW9uIHJlY3RhbmdsZS5cclxuICovXHJcbmZ1bmN0aW9uIGNvbXB1dGVJbnRlcnNlY3Rpb24ocm9vdFJlY3QsIHRhcmdldFJlY3QpIHtcclxuICAgIGNvbnN0IGxlZnQgICAgICA9IE1hdGgubWF4KHRhcmdldFJlY3QubGVmdCwgcm9vdFJlY3QubGVmdCk7XHJcbiAgICBjb25zdCByaWdodCAgICAgPSBNYXRoLm1pbih0YXJnZXRSZWN0LnJpZ2h0LCByb290UmVjdC5yaWdodCk7XHJcbiAgICBjb25zdCB0b3AgICAgICAgPSBNYXRoLm1heCh0YXJnZXRSZWN0LnRvcCwgcm9vdFJlY3QudG9wKTtcclxuICAgIGNvbnN0IGJvdHRvbSAgICA9IE1hdGgubWluKHRhcmdldFJlY3QuYm90dG9tLCByb290UmVjdC5ib3R0b20pO1xyXG5cclxuICAgIGNvbnN0IHdpZHRoID0gcmlnaHQgLSBsZWZ0O1xyXG4gICAgY29uc3QgaGVpZ2h0ID0gYm90dG9tIC0gdG9wO1xyXG5cclxuICAgIHJldHVybiBjcmVhdGVSZWN0YW5nbGUobGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEZpbmRzIGludGVyc2VjdGlvbiByZWN0YW5nbGUgb2YgcHJvdmlkZWQgZWxlbWVudHMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gY29udGFpbmVyIC0gQ29udGFpbmVyIGVsZW1lbnQuXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gVGFyZ2V0IGVsZW1lbnQuXHJcbiAqIEBwYXJhbSB7Q2xpZW50UmVjdH0gdGFyZ2V0UmVjdCAtIFJlY3RhbmdsZSBvZiB0YXJnZXQgZWxlbWVudC5cclxuICogQHBhcmFtIHtDbGllbnRSZWN0fSBjb250YWludGVyUmVjdCAtIFJlY3RhbmdsZSBvZiBjb250YWluZXIgZWxlbWVudC5cclxuICovXHJcbmZ1bmN0aW9uIGdldEludGVyc2VjdGlvbihjb250YWluZXIsIHRhcmdldCwgY29udGFpbnRlclJlY3QsIHRhcmdldFJlY3QpIHtcclxuICAgIGxldCBpbnRlcnNlY1JlY3QgICAgPSB0YXJnZXRSZWN0LFxyXG4gICAgICAgIHBhcmVudCAgICAgICAgICA9IHRhcmdldC5wYXJlbnROb2RlLFxyXG4gICAgICAgIHJvb3RSZWFjaGVkICAgICA9IGZhbHNlO1xyXG5cclxuICAgIHdoaWxlICghcm9vdFJlYWNoZWQpIHtcclxuICAgICAgICBsZXQgcGFyZW50UmVjdCA9IG51bGw7XHJcblxyXG4gICAgICAgIGlmIChwYXJlbnQgPT09IGNvbnRhaW5lciB8fCBwYXJlbnQubm9kZVR5cGUgIT09IDEpIHtcclxuICAgICAgICAgICAgcm9vdFJlYWNoZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBwYXJlbnRSZWN0ID0gY29udGFpbnRlclJlY3Q7XHJcbiAgICAgICAgfSBlbHNlIGlmICh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShwYXJlbnQpLm92ZXJmbG93ICE9PSAndmlzaWJsZScpIHtcclxuICAgICAgICAgICAgcGFyZW50UmVjdCA9IGdldFJlY3RhbmdsZShwYXJlbnQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHBhcmVudFJlY3QpIHtcclxuICAgICAgICAgICAgaW50ZXJzZWNSZWN0ID0gY29tcHV0ZUludGVyc2VjdGlvbihpbnRlcnNlY1JlY3QsIHBhcmVudFJlY3QpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGludGVyc2VjUmVjdDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoaXMgY2xhc3MgaXMgcmVzcG9uc2libGUgZm9yIGNvbXB1dGluZyBhbmQga2VlcGluZyB0cmFjayBvZiBpbnRlcnNlY3Rpb25zXHJcbiAqIGJldHdlZW4gdGFyZ2V0IGVsZW1lbnQgYW5kIGl0cyBjb250YWluZXIuIEl0IHdpbGwgY3JlYXRlIGFuZCBxdWV1ZSBmb3Igbm90aWZpY2F0aW9uXHJcbiAqIG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlckVudHJ5IHdoZW4gaW50ZXJzZWN0aW9uIHJhdGlvIHJlYWNoZXMgbmV3IHRocmVzaG9sZGVkIHZhbHVlLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW50ZXJzZWN0aW9uT2JzZXJ2YXRpb24ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGluc3RhbmNlIG9mIEludGVyc2VjdGlvbk9ic2VydmF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCBiZWluZyBvYnNlcnZlZC5cclxuICAgICAqIEBwYXJhbSB7SW50ZXJzZWN0aW9uT2JzZXJ2ZXJ9IG9ic2VydmVyIC0gQXNzb2NpYXRlZCBJbnRlcnNlY3Rpb25PYnNlcnZlci5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBvYnNlcnZlcikge1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcclxuXHJcbiAgICAgICAgdGhpcy5wcmV2VGFyZ2V0UmVjdCA9IGVtcHR5UmVjdDtcclxuICAgICAgICB0aGlzLnByZXZUaHJlc2hvbGQgPSAwO1xyXG4gICAgICAgIHRoaXMucHJldlJhdGlvID0gMDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgaW50ZXJzZWN0aW9uIGRhdGEuIENyZWF0ZXMgYW5kIHF1ZXVlcyBuZXdcclxuICAgICAqIEludGVyc2VjdGlvbk9ic2VydmVyRW50cnkgaWYgaW50ZXJzZWN0aW9uIHRocmVzaG9sZCBoYXMgY2hhbmdlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcm9vdCAtIEVsZW1lbnQgZm9yIHdoaWNoIHRvIGNvbXB1dGUgaW50ZXJzZWN0aW9uLlxyXG4gICAgICogQHBhcmFtIHtDbGllbnRSZWN0fSByb290UmVjdCAtIFJlY3RhbmdsZSBvZiByb290IGVsZW1lbnQuXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBpbmZvcm1hdGlvbiBhYm91dCBkZXRlY3RlZCBjaGFuZ2VzOlxyXG4gICAgICogIHtcclxuICAgICAqICAgICAgcmF0aW9DaGFuZ2VkOiBib29sZWFuLFxyXG4gICAgICogICAgICB0YXJnZXRSZWN0Q2hhbmdlZDogYm9vbGVhbixcclxuICAgICAqICAgICAgdGhyZXNob2xkQ2hhbmdlZDogYm9vbGVhblxyXG4gICAgICogIH1cclxuICAgICAqL1xyXG4gICAgdXBkYXRlSW50ZXJzZWN0aW9uKHJvb3QsIHJvb3RSZWN0KSB7XHJcbiAgICAgICAgbGV0IHRhcmdldFJlY3QgICAgICAgICAgPSBnZXRSZWN0YW5nbGUodGhpcy50YXJnZXQpLFxyXG4gICAgICAgICAgICBpbnRlcnNlY3Rpb24gICAgICAgID0gdGhpcy5nZXRJbnRlcnNlY3Rpb25EYXRhKHJvb3QsIHJvb3RSZWN0LCB0YXJnZXRSZWN0KSxcclxuICAgICAgICAgICAgdGhyZXNob2xkICAgICAgICAgICA9ICtpbnRlcnNlY3Rpb24uZXhpc3RzLFxyXG4gICAgICAgICAgICByYXRpb0NoYW5nZWQgICAgICAgID0gaW50ZXJzZWN0aW9uLnJhdGlvICE9PSB0aGlzLnByZXZSYXRpbyxcclxuICAgICAgICAgICAgdGFyZ2V0UmVjdENoYW5nZWQgICA9ICFpc0VxdWFsKHRhcmdldFJlY3QsIHRoaXMucHJldlRhcmdldFJlY3QpLFxyXG4gICAgICAgICAgICB0aHJlc2hvbGRDaGFuZ2VkO1xyXG5cclxuICAgICAgICAvLyBGaW5kIHRocmVzaG9sZHMnIGluZGV4IGlmIGludGVyc2VjdGlvblxyXG4gICAgICAgIC8vIGFuZCB0YXJnZXQgcmVjdGFuZ2xlcyBhcmUgbm90IGVtcHR5LlxyXG4gICAgICAgIGlmIChpbnRlcnNlY3Rpb24uZXhpc3RzICYmICFpc0VtcHR5KHRhcmdldFJlY3QpKSB7XHJcbiAgICAgICAgICAgIHRocmVzaG9sZCA9IHRoaXMub2JzZXJ2ZXIuZ2V0VGhyZXNob2xkR3JlYXRlclRoYW4oaW50ZXJzZWN0aW9uLnJhdGlvKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRocmVzaG9sZENoYW5nZWQgPSB0aHJlc2hvbGQgIT09IHRoaXMucHJldlRocmVzaG9sZDtcclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIGNhY2hlZCBwcm9wZXJ0aWVzLlxyXG4gICAgICAgIHRoaXMucHJldlRhcmdldFJlY3QgPSB0YXJnZXRSZWN0O1xyXG4gICAgICAgIHRoaXMucHJldlRocmVzaG9sZCA9IHRocmVzaG9sZDtcclxuICAgICAgICB0aGlzLnByZXZSYXRpbyA9IGludGVyc2VjdGlvbi5yYXRpbztcclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIGFuIGVtcHR5IHJlY3RhbmdsZSBpZiB0aGVyZSBpcyBubyBpbnRlcnNlY3Rpb24uXHJcbiAgICAgICAgaWYgKCFpbnRlcnNlY3Rpb24uZXhpc3RzKSB7XHJcbiAgICAgICAgICAgIGludGVyc2VjdGlvbi5yYXRpbyA9IDA7XHJcbiAgICAgICAgICAgIGludGVyc2VjdGlvbi5yZWN0ID0gZW1wdHlSZWN0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIGFuZCBxdWV1ZSBuZXcgZW50cnkgaWYgdGhyZXNob2xkIGhhcyBjaGFuZ2VkLlxyXG4gICAgICAgIGlmICh0aHJlc2hvbGRDaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVudHJ5ID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyRW50cnkoXHJcbiAgICAgICAgICAgICAgICB0aGlzLnRhcmdldCxcclxuICAgICAgICAgICAgICAgIHRhcmdldFJlY3QsXHJcbiAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb24ucmVjdCxcclxuICAgICAgICAgICAgICAgIGludGVyc2VjdGlvbi5yYXRpbyxcclxuICAgICAgICAgICAgICAgIHJvb3RSZWN0LFxyXG4gICAgICAgICAgICAgICAgbm93KClcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIucXVldWVFbnRyeShlbnRyeSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4ge3JhdGlvQ2hhbmdlZCwgdGhyZXNob2xkQ2hhbmdlZCwgdGFyZ2V0UmVjdENoYW5nZWR9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZXMgaW50ZXJzZWN0aW9uIGRhdGEuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBjb250YWluZXIgLSBDb250YWluZXIgZWxlbWVudC5cclxuICAgICAqIEBwYXJhbSB7Q2xpZW50UmVjdH0gW2NvbnRhaW50ZXJSZWN0XVxyXG4gICAgICogQHBhcmFtIHtDbGllbnRSZWN0fSBbdGFyZ2V0UmVjdF1cclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XHJcbiAgICAgKi9cclxuICAgIGdldEludGVyc2VjdGlvbkRhdGEoY29udGFpbmVyLCBjb250YWludGVyUmVjdCwgdGFyZ2V0UmVjdCkge1xyXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMudGFyZ2V0O1xyXG5cclxuICAgICAgICBpZiAoIXRhcmdldFJlY3QpIHtcclxuICAgICAgICAgICAgdGFyZ2V0UmVjdCA9IGdldFJlY3RhbmdsZSh0aGlzLnRhcmdldCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWNvbnRhaW50ZXJSZWN0KSB7XHJcbiAgICAgICAgICAgIGNvbnRhaW50ZXJSZWN0ID0gZ2V0UmVjdGFuZ2xlKGNvbnRhaW5lcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgZGV0YWNoZWQgICAgICAgID0gaXNEZXRhY2hlZChjb250YWluZXIsIHRhcmdldCksXHJcbiAgICAgICAgICAgIGludGVyc2VjUmVjdCAgICA9ICFkZXRhY2hlZCA/IGdldEludGVyc2VjdGlvbihjb250YWluZXIsIHRhcmdldCwgY29udGFpbnRlclJlY3QsIHRhcmdldFJlY3QpIDogZW1wdHlSZWN0LFxyXG4gICAgICAgICAgICBpbnRlcnNlY3RzICAgICAgPSAhZGV0YWNoZWQgJiYgaW50ZXJzZWNSZWN0LndpZHRoID49IDAgJiYgaW50ZXJzZWNSZWN0LmhlaWdodCA+PSAwLFxyXG4gICAgICAgICAgICBpbnRlcnNlY1JhdGlvICAgPSBnZXRBcmVhKGludGVyc2VjUmVjdCkgLyBnZXRBcmVhKHRhcmdldFJlY3QpIHx8IDA7XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHJlY3Q6IGludGVyc2VjUmVjdCxcclxuICAgICAgICAgICAgcmF0aW86IGludGVyc2VjUmF0aW8sXHJcbiAgICAgICAgICAgIGV4aXN0czogaW50ZXJzZWN0c1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/intersection-observer-polyfill/src/IntersectionObservation.js\n')},"./node_modules/intersection-observer-polyfill/src/IntersectionObserver.js":/*!*********************************************************************************!*\
  !*** ./node_modules/intersection-observer-polyfill/src/IntersectionObserver.js ***!
  \*********************************************************************************//*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){'use strict';eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _shims_es6_collections__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shims/es6-collections */ "./node_modules/intersection-observer-polyfill/src/shims/es6-collections.js");\n/* harmony import */ var _IntersectionObserverController__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./IntersectionObserverController */ "./node_modules/intersection-observer-polyfill/src/IntersectionObserverController.js");\n/* harmony import */ var _IntersectionObserver__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_IntersectionObserver */ "./node_modules/intersection-observer-polyfill/src/_IntersectionObserver.js");\n\r\n\r\n\r\n\r\n// This controllers\' instance will be assigned to all IntersectionObservers\r\nconst controller = new _IntersectionObserverController__WEBPACK_IMPORTED_MODULE_1__["default"]();\r\n\r\n// Registry of internal observers.\r\nconst observers = new _shims_es6_collections__WEBPACK_IMPORTED_MODULE_0__["WeakMap"]();\r\n\r\n/**\r\n * IntersectionObservers\' "Proxy" class which is meant to hide private\r\n * properties and methods from IntersectionObserver instances.\r\n *\r\n * Additionally it implements "idleTimeout" and "trackHovers" static property\r\n * accessors to give a control over the behavior of IntersectionObserverController\r\n * instance. Changes made to these properties will affect both future and\r\n * existing instances of IntersectionObserver.\r\n */\r\nclass IntersectionObserver {\r\n    /**\r\n     * Creates instance of public IntersectionObserver.\r\n     *\r\n     * @param {Function} callback\r\n     * @param {Object} options\r\n     */\r\n    constructor(callback, options) {\r\n        if (!arguments.length) {\r\n            throw new TypeError("1 argument required, but only 0 present.");\r\n        }\r\n\r\n        const observer = new _IntersectionObserver__WEBPACK_IMPORTED_MODULE_2__["default"](callback, options, controller, this);\r\n\r\n        // Due to the spec following properties are non-writable\r\n        // and in native implementation they are also not enumerable.\r\n        Object.defineProperties(this, {\r\n            root:       {value: observer.root},\r\n            thresholds: {value: observer.thresholds},\r\n            rootMargin: {value: observer.rootMargin}\r\n        });\r\n\r\n        // Register internal observer.\r\n        observers.set(this, observer);\r\n    }\r\n\r\n    /**\r\n     * Extracts controllers\' idle timeout value.\r\n     *\r\n     * @returns {Number}\r\n     */\r\n    static get idleTimeout() {\r\n        return controller.idleTimeout;\r\n    }\r\n\r\n    /**\r\n     * Sets up new idle timeout.\r\n     *\r\n     * @param {Number} value - New timeout value.\r\n     */\r\n    static set idleTimeout(value) {\r\n        if (typeof value !== \'number\') {\r\n            throw new TypeError(\'type of "idleTimeout" value must be a number.\');\r\n        }\r\n\r\n        if (typeof value < 0) {\r\n            throw new TypeError(\'"idleTimeout" value must be greater than 0.\');\r\n        }\r\n\r\n        controller.idleTimeout = value;\r\n    }\r\n\r\n    /**\r\n     * Tells whether controller tracks "hover" events.\r\n     *\r\n     * @returns {Boolean}\r\n     */\r\n    static get trackHovers() {\r\n        return controller.isHoverEnabled();\r\n    }\r\n\r\n    /**\r\n     * Enables or disables tracking of "hover" event.\r\n     *\r\n     * @param {Boolean} value - Whether to disable or enable tracking.\r\n     */\r\n    static set trackHovers(value) {\r\n        if (typeof value !== \'boolean\') {\r\n            throw new TypeError(\'type of "trackHovers" value must be a boolean.\');\r\n        }\r\n\r\n        value ?\r\n            controller.enableHover() :\r\n            controller.disableHover();\r\n    }\r\n}\r\n\r\n// Expose public methods of IntersectionObserver.\r\n[\r\n    \'observe\',\r\n    \'unobserve\',\r\n    \'disconnect\',\r\n    \'takeRecords\'\r\n].forEach(method => {\r\n    IntersectionObserver.prototype[method] = function () {\r\n        return observers.get(this)[method](...arguments);\r\n    };\r\n});\r\n\r\n/* harmony default export */ __webpack_exports__["default"] = (IntersectionObserver);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW50ZXJzZWN0aW9uLW9ic2VydmVyLXBvbHlmaWxsL3NyYy9JbnRlcnNlY3Rpb25PYnNlcnZlci5qcz80YWMyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQWdEO0FBQzhCO0FBQ2xCOztBQUU1RDtBQUNBLHVCQUF1Qix1RUFBOEI7O0FBRXJEO0FBQ0Esc0JBQXNCLDhEQUFPOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkIsNkRBQXFCOztBQUVsRDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIscUJBQXFCO0FBQzlDLHlCQUF5QiwyQkFBMkI7QUFDcEQseUJBQXlCO0FBQ3pCLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRWMsbUZBQW9CLEVBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaW50ZXJzZWN0aW9uLW9ic2VydmVyLXBvbHlmaWxsL3NyYy9JbnRlcnNlY3Rpb25PYnNlcnZlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7V2Vha01hcH0gZnJvbSAnLi9zaGltcy9lczYtY29sbGVjdGlvbnMnO1xyXG5pbXBvcnQgSW50ZXJzZWN0aW9uT2JzZXJ2ZXJDb250cm9sbGVyIGZyb20gJy4vSW50ZXJzZWN0aW9uT2JzZXJ2ZXJDb250cm9sbGVyJztcclxuaW1wb3J0IF9JbnRlcnNlY3Rpb25PYnNlcnZlciBmcm9tICcuL19JbnRlcnNlY3Rpb25PYnNlcnZlcic7XHJcblxyXG4vLyBUaGlzIGNvbnRyb2xsZXJzJyBpbnN0YW5jZSB3aWxsIGJlIGFzc2lnbmVkIHRvIGFsbCBJbnRlcnNlY3Rpb25PYnNlcnZlcnNcclxuY29uc3QgY29udHJvbGxlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlckNvbnRyb2xsZXIoKTtcclxuXHJcbi8vIFJlZ2lzdHJ5IG9mIGludGVybmFsIG9ic2VydmVycy5cclxuY29uc3Qgb2JzZXJ2ZXJzID0gbmV3IFdlYWtNYXAoKTtcclxuXHJcbi8qKlxyXG4gKiBJbnRlcnNlY3Rpb25PYnNlcnZlcnMnIFwiUHJveHlcIiBjbGFzcyB3aGljaCBpcyBtZWFudCB0byBoaWRlIHByaXZhdGVcclxuICogcHJvcGVydGllcyBhbmQgbWV0aG9kcyBmcm9tIEludGVyc2VjdGlvbk9ic2VydmVyIGluc3RhbmNlcy5cclxuICpcclxuICogQWRkaXRpb25hbGx5IGl0IGltcGxlbWVudHMgXCJpZGxlVGltZW91dFwiIGFuZCBcInRyYWNrSG92ZXJzXCIgc3RhdGljIHByb3BlcnR5XHJcbiAqIGFjY2Vzc29ycyB0byBnaXZlIGEgY29udHJvbCBvdmVyIHRoZSBiZWhhdmlvciBvZiBJbnRlcnNlY3Rpb25PYnNlcnZlckNvbnRyb2xsZXJcclxuICogaW5zdGFuY2UuIENoYW5nZXMgbWFkZSB0byB0aGVzZSBwcm9wZXJ0aWVzIHdpbGwgYWZmZWN0IGJvdGggZnV0dXJlIGFuZFxyXG4gKiBleGlzdGluZyBpbnN0YW5jZXMgb2YgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIuXHJcbiAqL1xyXG5jbGFzcyBJbnRlcnNlY3Rpb25PYnNlcnZlciB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgaW5zdGFuY2Ugb2YgcHVibGljIEludGVyc2VjdGlvbk9ic2VydmVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihjYWxsYmFjaywgb3B0aW9ucykge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgMCBwcmVzZW50LlwiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IF9JbnRlcnNlY3Rpb25PYnNlcnZlcihjYWxsYmFjaywgb3B0aW9ucywgY29udHJvbGxlciwgdGhpcyk7XHJcblxyXG4gICAgICAgIC8vIER1ZSB0byB0aGUgc3BlYyBmb2xsb3dpbmcgcHJvcGVydGllcyBhcmUgbm9uLXdyaXRhYmxlXHJcbiAgICAgICAgLy8gYW5kIGluIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiB0aGV5IGFyZSBhbHNvIG5vdCBlbnVtZXJhYmxlLlxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcclxuICAgICAgICAgICAgcm9vdDogICAgICAge3ZhbHVlOiBvYnNlcnZlci5yb290fSxcclxuICAgICAgICAgICAgdGhyZXNob2xkczoge3ZhbHVlOiBvYnNlcnZlci50aHJlc2hvbGRzfSxcclxuICAgICAgICAgICAgcm9vdE1hcmdpbjoge3ZhbHVlOiBvYnNlcnZlci5yb290TWFyZ2lufVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBSZWdpc3RlciBpbnRlcm5hbCBvYnNlcnZlci5cclxuICAgICAgICBvYnNlcnZlcnMuc2V0KHRoaXMsIG9ic2VydmVyKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEV4dHJhY3RzIGNvbnRyb2xsZXJzJyBpZGxlIHRpbWVvdXQgdmFsdWUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldCBpZGxlVGltZW91dCgpIHtcclxuICAgICAgICByZXR1cm4gY29udHJvbGxlci5pZGxlVGltZW91dDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdXAgbmV3IGlkbGUgdGltZW91dC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBOZXcgdGltZW91dCB2YWx1ZS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHNldCBpZGxlVGltZW91dCh2YWx1ZSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3R5cGUgb2YgXCJpZGxlVGltZW91dFwiIHZhbHVlIG11c3QgYmUgYSBudW1iZXIuJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlIDwgMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImlkbGVUaW1lb3V0XCIgdmFsdWUgbXVzdCBiZSBncmVhdGVyIHRoYW4gMC4nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnRyb2xsZXIuaWRsZVRpbWVvdXQgPSB2YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlbGxzIHdoZXRoZXIgY29udHJvbGxlciB0cmFja3MgXCJob3ZlclwiIGV2ZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldCB0cmFja0hvdmVycygpIHtcclxuICAgICAgICByZXR1cm4gY29udHJvbGxlci5pc0hvdmVyRW5hYmxlZCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRW5hYmxlcyBvciBkaXNhYmxlcyB0cmFja2luZyBvZiBcImhvdmVyXCIgZXZlbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSAtIFdoZXRoZXIgdG8gZGlzYWJsZSBvciBlbmFibGUgdHJhY2tpbmcuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBzZXQgdHJhY2tIb3ZlcnModmFsdWUpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnYm9vbGVhbicpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndHlwZSBvZiBcInRyYWNrSG92ZXJzXCIgdmFsdWUgbXVzdCBiZSBhIGJvb2xlYW4uJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YWx1ZSA/XHJcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5hYmxlSG92ZXIoKSA6XHJcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZGlzYWJsZUhvdmVyKCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8vIEV4cG9zZSBwdWJsaWMgbWV0aG9kcyBvZiBJbnRlcnNlY3Rpb25PYnNlcnZlci5cclxuW1xyXG4gICAgJ29ic2VydmUnLFxyXG4gICAgJ3Vub2JzZXJ2ZScsXHJcbiAgICAnZGlzY29ubmVjdCcsXHJcbiAgICAndGFrZVJlY29yZHMnXHJcbl0uZm9yRWFjaChtZXRob2QgPT4ge1xyXG4gICAgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG9ic2VydmVycy5nZXQodGhpcylbbWV0aG9kXSguLi5hcmd1bWVudHMpO1xyXG4gICAgfTtcclxufSk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBJbnRlcnNlY3Rpb25PYnNlcnZlcjtcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/intersection-observer-polyfill/src/IntersectionObserver.js\n')},"./node_modules/intersection-observer-polyfill/src/IntersectionObserverController.js":/*!*******************************************************************************************!*\
  !*** ./node_modules/intersection-observer-polyfill/src/IntersectionObserverController.js ***!
  \*******************************************************************************************//*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){'use strict';eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return IntersectionObserverController; });\n/* harmony import */ var _shims_performance_now__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shims/performance.now */ "./node_modules/intersection-observer-polyfill/src/shims/performance.now.js");\n\r\n\r\nconst mutationsSupported = typeof window.MutationObserver === \'function\';\r\n\r\n/**\r\n * A shim for requestAnimationFrame which falls back\r\n * to setTimeout if the first one is not supported.\r\n *\r\n * @returns {Number} Request identifier.\r\n */\r\nconst requestAnimFrame = (function () {\r\n    if (window.requestAnimationFrame) {\r\n        return window.requestAnimationFrame;\r\n    }\r\n\r\n    return callback => {\r\n        return setTimeout(() => callback(Object(_shims_performance_now__WEBPACK_IMPORTED_MODULE_0__["default"])()), 1000 / 60);\r\n    };\r\n})();\r\n\r\n/**\r\n * Creates a wrapper function that ensures that\r\n * provided callback will be invoked only after\r\n * the specified delay.\r\n *\r\n * @param {Function} callback\r\n * @param {Number} [delay = 0]\r\n * @returns {Function}\r\n */\r\nfunction debounce(callback, delay = 0) {\r\n    let timeoutID = false;\r\n\r\n    return function (...args) {\r\n        if (timeoutID !== false) {\r\n            clearTimeout(timeoutID);\r\n        }\r\n\r\n        timeoutID = setTimeout(() => {\r\n            timeoutID = false;\r\n\r\n            callback.apply(this, args);\r\n        }, delay);\r\n    };\r\n}\r\n\r\n/**\r\n * Controller class that is used to handle updates of registered IntersectionObservers.\r\n * It controls when and for how long it\'s necessary to run updates of observations\r\n * by listening to various events on window along with DOM mutations\r\n * (nodes removal, changes of attributes, etc.).\r\n  *\r\n * CSS transitions and animations are handled by running the update cycle\r\n * until position of DOM elements, added to connected observers, keeps changing\r\n * or until the idle timeout is reached (default timeout is 50 milliseconds).\r\n * Timeout value can be manually increased if transitions have a delay.\r\n *\r\n * Tracking of changes made by ":hover" class is optional and can be\r\n * enabled by invoking the "enableHover" method.\r\n *\r\n * Infinite update cycle along with a listener of "click" event will be used in case when\r\n * MutatioObserver is not supported.\r\n */\r\nclass IntersectionObserverController {\r\n    /**\r\n     * Creates new IntersectionObserverController instance.\r\n     *\r\n     * @param {Number} [idleTimeout = 50]\r\n     * @pram {Boolean} [trackHovers = false] - Whether to track "mouseover"\r\n     *      events or not. Disabled be default.\r\n     */\r\n    constructor(idleTimeout = 50, trackHovers = false) {\r\n        this._idleTimeout = idleTimeout;\r\n        this._trackHovers = trackHovers;\r\n        this._cycleStartTime = -1;\r\n\r\n        // Indicates whether the update of observers is scheduled.\r\n        this._isUpdateScheduled = false;\r\n\r\n        // Indicates whether infinite cycles are enabled.\r\n        this._repeatCycle = false;\r\n\r\n        // Indicates whether "mouseover" event handler was added.\r\n        this._hoverInitiated = false;\r\n\r\n        // Keeps reference to the instance of MutationObserver.\r\n        this._mutationsObserver = null;\r\n\r\n        // Indicates whether DOM listeners were initiated.\r\n        this._isListening = false;\r\n\r\n        // A list of connected observers.\r\n        this._observers = [];\r\n\r\n        // Fix value of "this" binding for the following methods.\r\n        this.startUpdateCycle = this.startUpdateCycle.bind(this);\r\n        this.scheduleUpdate = this.scheduleUpdate.bind(this);\r\n        this._onMutation = this._onMutation.bind(this);\r\n\r\n        // Function that will be invoked to re-rerun the update cycle\r\n        // if repeatable cycles are enabled.\r\n        this._repeatHandler = debounce(this.scheduleUpdate, 200);\r\n\r\n        // "mouseover" event handler.\r\n        this._onMouseOver = debounce(this.startUpdateCycle, 200);\r\n    }\r\n\r\n    /**\r\n     * Returns current idle timeout value.\r\n     *\r\n     * @returns {Number}\r\n     */\r\n    get idleTimeout() {\r\n        return this._idleTimeout;\r\n    }\r\n\r\n    /**\r\n     * Sets up new idle timeout value.\r\n     *\r\n     * @param {Number} value - New timeout value.\r\n     */\r\n    set idleTimeout(value) {\r\n        this._idleTimeout = value;\r\n    }\r\n\r\n    /**\r\n     * Adds observer to observers list.\r\n     *\r\n     * @param {IntersectionObserver} observer - Observer to be added.\r\n     */\r\n    connect(observer) {\r\n        if (!this.isConnected(observer)) {\r\n            this._observers.push(observer);\r\n        }\r\n\r\n        // Instantiate listeners if they\r\n        // weren\'t instantiated yet.\r\n        if (!this._isListening) {\r\n            this._initListeners();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes observer from observers list.\r\n     *\r\n     * @param {IntersectionObserver} observer - Observer to be removed.\r\n     */\r\n    disconnect(observer) {\r\n        let observers = this._observers,\r\n            index = observers.indexOf(observer);\r\n\r\n        if (~index) {\r\n            observers.splice(index, 1);\r\n        }\r\n\r\n        // Remove listeners if controller\r\n        // has no connected observers.\r\n        if (!observers.length && this._isListening) {\r\n            this._removeListeners();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Tells whether provided observer is connected to controller.\r\n     *\r\n     * @param {IntersectionObserver} observer - Observer to be checked.\r\n     * @returns {Boolean}\r\n     */\r\n    isConnected(observer) {\r\n        return !!~this._observers.indexOf(observer);\r\n    }\r\n\r\n    /**\r\n     * Updates every observer from observers list and\r\n     * notifies them of queued entries.\r\n     *\r\n     * @private\r\n     * @returns {Boolean} Returns "true" if any observer\r\n     *      has detected changes in position of its elements.\r\n     */\r\n    _updateObservers() {\r\n        let hasChanges = false;\r\n\r\n        for (const observer of this._observers) {\r\n            if (observer.updateObservations()) {\r\n                hasChanges = true;\r\n            }\r\n\r\n            if (observer.hasEntries()) {\r\n                observer.notifySubscriber();\r\n            }\r\n        }\r\n\r\n        return hasChanges;\r\n    }\r\n\r\n    /**\r\n     * Schedules new update cycle.\r\n     */\r\n    startUpdateCycle() {\r\n        this._cycleStartTime = Object(_shims_performance_now__WEBPACK_IMPORTED_MODULE_0__["default"])();\r\n\r\n        this.scheduleUpdate();\r\n    }\r\n\r\n    /**\r\n     * Controls invocation of "_updateObservers" method.\r\n     * It will re-invoke itself in the following cases:\r\n     *      - Update of observers detected changes in elements position.\r\n     *        In this case we need to postpone cycle end time in order to ensure\r\n     *        that we won\'t miss next iteration of animations.\r\n     *\r\n     *      - Idle timeout wasn\'t reached yet.\r\n     *        In this case we need to schedule new single update\r\n     *        because changes may be delayed.\r\n     *\r\n     * @param {Number} [timestamp] - Internal parameter\r\n     *      that is used to define whether method was invoked\r\n     *      as a callback of requestAnimationFrame.\r\n     */\r\n    scheduleUpdate(timestamp) {\r\n        let calledFromRAF = typeof timestamp === \'number\';\r\n\r\n        // Invoke the update of observers only if function\r\n        // was called as a requestAnimationFrame callback.\r\n        if (calledFromRAF) {\r\n            const hasChanges = this._updateObservers();\r\n\r\n            this._isUpdateScheduled = false;\r\n\r\n            // Do nothing if cycle wasn\'t started.\r\n            if (!this._wasCycleStarted()) {\r\n                return;\r\n            }\r\n\r\n            if (hasChanges) {\r\n                // Postpone cycle end time if changes were detected.\r\n                this.startUpdateCycle();\r\n            } else if (!this._hasIdleTimeEnded()) {\r\n                // Schedule new single update if cycle timeout wasn\'t reached yet.\r\n                this.scheduleUpdate();\r\n            } else {\r\n                // Finish cycle.\r\n                this._onCycleEnded();\r\n            }\r\n        } else if (!this._isUpdateScheduled) {\r\n            // Request new update if it wasn\'t requested already.\r\n            requestAnimFrame(this.scheduleUpdate);\r\n\r\n            this._isUpdateScheduled = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Tells whether cycle has reached its idle timeout.\r\n     *\r\n     * @private\r\n     * @returns {Boolean}\r\n     */\r\n    _hasIdleTimeEnded() {\r\n        return Object(_shims_performance_now__WEBPACK_IMPORTED_MODULE_0__["default"])() - this._cycleStartTime > this._idleTimeout;\r\n    }\r\n\r\n    /**\r\n     * Tells whether the update cycle is currently running.\r\n     *\r\n     * @private\r\n     * @returns {Boolean}\r\n     */\r\n    _wasCycleStarted() {\r\n        return this._cycleStartTime !== -1;\r\n    }\r\n\r\n    /**\r\n     * Callback that will be invoked after the update cycle is finished.\r\n     *\r\n     * @private\r\n     */\r\n    _onCycleEnded() {\r\n        // Mark that update cycle is not running.\r\n        this._cycleStartTime = -1;\r\n\r\n        if (this._repeatCycle) {\r\n            // Time is set to \'0\' because we want to automatically\r\n            // start update cycle when single update detects changes.\r\n            this._cycleStartTime = 0;\r\n\r\n            this._repeatHandler();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Initializes DOM listeners.\r\n     *\r\n     * @private\r\n     */\r\n    _initListeners() {\r\n        // Do nothing if listeners are already initiated.\r\n        if (this._isListening) {\r\n            return;\r\n        }\r\n\r\n        this._isListening = true;\r\n\r\n        // Use update cycle here instead of a single update because we may encounter\r\n        // with delayed changes, e.g. when width or height of an\r\n        // element are changed by CSS transitions.\r\n        window.addEventListener(\'resize\', this.startUpdateCycle, true);\r\n\r\n        window.addEventListener(\'scroll\', this.scheduleUpdate, true);\r\n\r\n        // Listen to possible changes made by ":hover" class.\r\n        if (this._trackHovers) {\r\n            this._addHoverListener();\r\n        }\r\n\r\n        // Fall back to repeatable cycle with additional tracking of\r\n        // "click" event if MutationObserver is not supported.\r\n        if (!mutationsSupported) {\r\n            this._repeatCycle = true;\r\n\r\n            // Listen to clicks as they may cause changes in elements position.\r\n            window.addEventListener(\'click\', this.startUpdateCycle, true);\r\n\r\n            // Manually start cycle.\r\n            this.startUpdateCycle();\r\n        } else {\r\n            // Subscribe to DOM mutations as they may lead to changes in position of elements.\r\n            this._mutationsObserver = new MutationObserver(this._onMutation);\r\n\r\n            this._mutationsObserver.observe(document, {\r\n                attributes: true,\r\n                childList: true,\r\n                characterData: true,\r\n                subtree: true\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes all DOM listeners.\r\n     *\r\n     * @private\r\n     */\r\n    _removeListeners() {\r\n        // Do nothing if listeners were already removed.\r\n        if (!this._isListening) {\r\n            return;\r\n        }\r\n\r\n        window.removeEventListener(\'resize\', this.startUpdateCycle, true);\r\n        window.removeEventListener(\'scroll\', this.scheduleUpdate, true);\r\n\r\n        this._removeHoverListener();\r\n\r\n        if (!mutationsSupported) {\r\n            this._repeatCycle = false;\r\n\r\n            window.removeEventListener(\'click\', this.startUpdateCycle, true);\r\n        } else if (this._mutationsObserver) {\r\n            this._mutationsObserver.disconnect();\r\n            this._mutationsObserver = null;\r\n        }\r\n\r\n        this._isListening = false;\r\n    }\r\n\r\n    /**\r\n     * Enables hover listener.\r\n     */\r\n    enableHover() {\r\n        this._trackHovers = true;\r\n\r\n        // Manually add hover listener\r\n        // if listeners were already initiated.\r\n        if (this._isListening) {\r\n            this._addHoverListener();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disables hover listener.\r\n     */\r\n    disableHover() {\r\n        this._trackHovers = false;\r\n\r\n        this._removeHoverListener();\r\n    }\r\n\r\n    /**\r\n     * Tells whether hover listener is enabled.\r\n     *\r\n     * @returns {Boolean}\r\n     */\r\n    isHoverEnabled() {\r\n        return this._trackHovers;\r\n    }\r\n\r\n    /**\r\n     * Adds "mouseover" listener if it wasn\'t already added.\r\n     *\r\n     * @private\r\n     */\r\n    _addHoverListener() {\r\n        if (this._hoverInitiated) {\r\n            return;\r\n        }\r\n\r\n        window.addEventListener(\'mouseover\', this._onMouseOver, true);\r\n\r\n        this._hoverInitiated = true;\r\n    }\r\n\r\n    /**\r\n     * Removes "mouseover" listener if it was added previously.\r\n     *\r\n     * @private\r\n     */\r\n    _removeHoverListener() {\r\n        if (!this._hoverInitiated) {\r\n            return;\r\n        }\r\n\r\n        window.removeEventListener(\'mouseover\', this._onMouseOver, true);\r\n\r\n        this._hoverInitiated = false;\r\n    }\r\n\r\n    /**\r\n     * DOM mutations handler.\r\n     *\r\n     * @private\r\n     * @param {Array<MutationRecord>} entries\r\n     */\r\n    _onMutation(entries) {\r\n        const runSingleUpdate = entries.every(entry => {\r\n            return entry.type !== \'attributes\';\r\n        });\r\n\r\n        // Schedule single update if attributes (class, style, etc.)\r\n        // were not changed. Otherwise run update cycle because\r\n        // animations are expected to appear only in this case.\r\n        runSingleUpdate ?\r\n            this.scheduleUpdate() :\r\n            this.startUpdateCycle();\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW50ZXJzZWN0aW9uLW9ic2VydmVyLXBvbHlmaWxsL3NyYy9JbnRlcnNlY3Rpb25PYnNlcnZlckNvbnRyb2xsZXIuanM/N2IzZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBMEM7O0FBRTFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUMsc0VBQUc7QUFDNUM7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFCQUFxQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFCQUFxQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscUJBQXFCO0FBQ3BDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixzRUFBRzs7QUFFbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxlQUFlLHNFQUFHO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0JBQXNCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2ludGVyc2VjdGlvbi1vYnNlcnZlci1wb2x5ZmlsbC9zcmMvSW50ZXJzZWN0aW9uT2JzZXJ2ZXJDb250cm9sbGVyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG5vdyBmcm9tICcuL3NoaW1zL3BlcmZvcm1hbmNlLm5vdyc7XHJcblxyXG5jb25zdCBtdXRhdGlvbnNTdXBwb3J0ZWQgPSB0eXBlb2Ygd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIgPT09ICdmdW5jdGlvbic7XHJcblxyXG4vKipcclxuICogQSBzaGltIGZvciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgd2hpY2ggZmFsbHMgYmFja1xyXG4gKiB0byBzZXRUaW1lb3V0IGlmIHRoZSBmaXJzdCBvbmUgaXMgbm90IHN1cHBvcnRlZC5cclxuICpcclxuICogQHJldHVybnMge051bWJlcn0gUmVxdWVzdCBpZGVudGlmaWVyLlxyXG4gKi9cclxuY29uc3QgcmVxdWVzdEFuaW1GcmFtZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAod2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xyXG4gICAgICAgIHJldHVybiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjYWxsYmFjayA9PiB7XHJcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoKCkgPT4gY2FsbGJhY2sobm93KCkpLCAxMDAwIC8gNjApO1xyXG4gICAgfTtcclxufSkoKTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgd3JhcHBlciBmdW5jdGlvbiB0aGF0IGVuc3VyZXMgdGhhdFxyXG4gKiBwcm92aWRlZCBjYWxsYmFjayB3aWxsIGJlIGludm9rZWQgb25seSBhZnRlclxyXG4gKiB0aGUgc3BlY2lmaWVkIGRlbGF5LlxyXG4gKlxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xyXG4gKiBAcGFyYW0ge051bWJlcn0gW2RlbGF5ID0gMF1cclxuICogQHJldHVybnMge0Z1bmN0aW9ufVxyXG4gKi9cclxuZnVuY3Rpb24gZGVib3VuY2UoY2FsbGJhY2ssIGRlbGF5ID0gMCkge1xyXG4gICAgbGV0IHRpbWVvdXRJRCA9IGZhbHNlO1xyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xyXG4gICAgICAgIGlmICh0aW1lb3V0SUQgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SUQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGltZW91dElEID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIHRpbWVvdXRJRCA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICAgICAgfSwgZGVsYXkpO1xyXG4gICAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnRyb2xsZXIgY2xhc3MgdGhhdCBpcyB1c2VkIHRvIGhhbmRsZSB1cGRhdGVzIG9mIHJlZ2lzdGVyZWQgSW50ZXJzZWN0aW9uT2JzZXJ2ZXJzLlxyXG4gKiBJdCBjb250cm9scyB3aGVuIGFuZCBmb3IgaG93IGxvbmcgaXQncyBuZWNlc3NhcnkgdG8gcnVuIHVwZGF0ZXMgb2Ygb2JzZXJ2YXRpb25zXHJcbiAqIGJ5IGxpc3RlbmluZyB0byB2YXJpb3VzIGV2ZW50cyBvbiB3aW5kb3cgYWxvbmcgd2l0aCBET00gbXV0YXRpb25zXHJcbiAqIChub2RlcyByZW1vdmFsLCBjaGFuZ2VzIG9mIGF0dHJpYnV0ZXMsIGV0Yy4pLlxyXG4gICpcclxuICogQ1NTIHRyYW5zaXRpb25zIGFuZCBhbmltYXRpb25zIGFyZSBoYW5kbGVkIGJ5IHJ1bm5pbmcgdGhlIHVwZGF0ZSBjeWNsZVxyXG4gKiB1bnRpbCBwb3NpdGlvbiBvZiBET00gZWxlbWVudHMsIGFkZGVkIHRvIGNvbm5lY3RlZCBvYnNlcnZlcnMsIGtlZXBzIGNoYW5naW5nXHJcbiAqIG9yIHVudGlsIHRoZSBpZGxlIHRpbWVvdXQgaXMgcmVhY2hlZCAoZGVmYXVsdCB0aW1lb3V0IGlzIDUwIG1pbGxpc2Vjb25kcykuXHJcbiAqIFRpbWVvdXQgdmFsdWUgY2FuIGJlIG1hbnVhbGx5IGluY3JlYXNlZCBpZiB0cmFuc2l0aW9ucyBoYXZlIGEgZGVsYXkuXHJcbiAqXHJcbiAqIFRyYWNraW5nIG9mIGNoYW5nZXMgbWFkZSBieSBcIjpob3ZlclwiIGNsYXNzIGlzIG9wdGlvbmFsIGFuZCBjYW4gYmVcclxuICogZW5hYmxlZCBieSBpbnZva2luZyB0aGUgXCJlbmFibGVIb3ZlclwiIG1ldGhvZC5cclxuICpcclxuICogSW5maW5pdGUgdXBkYXRlIGN5Y2xlIGFsb25nIHdpdGggYSBsaXN0ZW5lciBvZiBcImNsaWNrXCIgZXZlbnQgd2lsbCBiZSB1c2VkIGluIGNhc2Ugd2hlblxyXG4gKiBNdXRhdGlvT2JzZXJ2ZXIgaXMgbm90IHN1cHBvcnRlZC5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEludGVyc2VjdGlvbk9ic2VydmVyQ29udHJvbGxlciB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgbmV3IEludGVyc2VjdGlvbk9ic2VydmVyQ29udHJvbGxlciBpbnN0YW5jZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2lkbGVUaW1lb3V0ID0gNTBdXHJcbiAgICAgKiBAcHJhbSB7Qm9vbGVhbn0gW3RyYWNrSG92ZXJzID0gZmFsc2VdIC0gV2hldGhlciB0byB0cmFjayBcIm1vdXNlb3ZlclwiXHJcbiAgICAgKiAgICAgIGV2ZW50cyBvciBub3QuIERpc2FibGVkIGJlIGRlZmF1bHQuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGlkbGVUaW1lb3V0ID0gNTAsIHRyYWNrSG92ZXJzID0gZmFsc2UpIHtcclxuICAgICAgICB0aGlzLl9pZGxlVGltZW91dCA9IGlkbGVUaW1lb3V0O1xyXG4gICAgICAgIHRoaXMuX3RyYWNrSG92ZXJzID0gdHJhY2tIb3ZlcnM7XHJcbiAgICAgICAgdGhpcy5fY3ljbGVTdGFydFRpbWUgPSAtMTtcclxuXHJcbiAgICAgICAgLy8gSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHVwZGF0ZSBvZiBvYnNlcnZlcnMgaXMgc2NoZWR1bGVkLlxyXG4gICAgICAgIHRoaXMuX2lzVXBkYXRlU2NoZWR1bGVkID0gZmFsc2U7XHJcblxyXG4gICAgICAgIC8vIEluZGljYXRlcyB3aGV0aGVyIGluZmluaXRlIGN5Y2xlcyBhcmUgZW5hYmxlZC5cclxuICAgICAgICB0aGlzLl9yZXBlYXRDeWNsZSA9IGZhbHNlO1xyXG5cclxuICAgICAgICAvLyBJbmRpY2F0ZXMgd2hldGhlciBcIm1vdXNlb3ZlclwiIGV2ZW50IGhhbmRsZXIgd2FzIGFkZGVkLlxyXG4gICAgICAgIHRoaXMuX2hvdmVySW5pdGlhdGVkID0gZmFsc2U7XHJcblxyXG4gICAgICAgIC8vIEtlZXBzIHJlZmVyZW5jZSB0byB0aGUgaW5zdGFuY2Ugb2YgTXV0YXRpb25PYnNlcnZlci5cclxuICAgICAgICB0aGlzLl9tdXRhdGlvbnNPYnNlcnZlciA9IG51bGw7XHJcblxyXG4gICAgICAgIC8vIEluZGljYXRlcyB3aGV0aGVyIERPTSBsaXN0ZW5lcnMgd2VyZSBpbml0aWF0ZWQuXHJcbiAgICAgICAgdGhpcy5faXNMaXN0ZW5pbmcgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgLy8gQSBsaXN0IG9mIGNvbm5lY3RlZCBvYnNlcnZlcnMuXHJcbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXJzID0gW107XHJcblxyXG4gICAgICAgIC8vIEZpeCB2YWx1ZSBvZiBcInRoaXNcIiBiaW5kaW5nIGZvciB0aGUgZm9sbG93aW5nIG1ldGhvZHMuXHJcbiAgICAgICAgdGhpcy5zdGFydFVwZGF0ZUN5Y2xlID0gdGhpcy5zdGFydFVwZGF0ZUN5Y2xlLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5zY2hlZHVsZVVwZGF0ZSA9IHRoaXMuc2NoZWR1bGVVcGRhdGUuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLl9vbk11dGF0aW9uID0gdGhpcy5fb25NdXRhdGlvbi5iaW5kKHRoaXMpO1xyXG5cclxuICAgICAgICAvLyBGdW5jdGlvbiB0aGF0IHdpbGwgYmUgaW52b2tlZCB0byByZS1yZXJ1biB0aGUgdXBkYXRlIGN5Y2xlXHJcbiAgICAgICAgLy8gaWYgcmVwZWF0YWJsZSBjeWNsZXMgYXJlIGVuYWJsZWQuXHJcbiAgICAgICAgdGhpcy5fcmVwZWF0SGFuZGxlciA9IGRlYm91bmNlKHRoaXMuc2NoZWR1bGVVcGRhdGUsIDIwMCk7XHJcblxyXG4gICAgICAgIC8vIFwibW91c2VvdmVyXCIgZXZlbnQgaGFuZGxlci5cclxuICAgICAgICB0aGlzLl9vbk1vdXNlT3ZlciA9IGRlYm91bmNlKHRoaXMuc3RhcnRVcGRhdGVDeWNsZSwgMjAwKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgY3VycmVudCBpZGxlIHRpbWVvdXQgdmFsdWUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgZ2V0IGlkbGVUaW1lb3V0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pZGxlVGltZW91dDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdXAgbmV3IGlkbGUgdGltZW91dCB2YWx1ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBOZXcgdGltZW91dCB2YWx1ZS5cclxuICAgICAqL1xyXG4gICAgc2V0IGlkbGVUaW1lb3V0KHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5faWRsZVRpbWVvdXQgPSB2YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgb2JzZXJ2ZXIgdG8gb2JzZXJ2ZXJzIGxpc3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtJbnRlcnNlY3Rpb25PYnNlcnZlcn0gb2JzZXJ2ZXIgLSBPYnNlcnZlciB0byBiZSBhZGRlZC5cclxuICAgICAqL1xyXG4gICAgY29ubmVjdChvYnNlcnZlcikge1xyXG4gICAgICAgIGlmICghdGhpcy5pc0Nvbm5lY3RlZChvYnNlcnZlcikpIHtcclxuICAgICAgICAgICAgdGhpcy5fb2JzZXJ2ZXJzLnB1c2gob2JzZXJ2ZXIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSW5zdGFudGlhdGUgbGlzdGVuZXJzIGlmIHRoZXlcclxuICAgICAgICAvLyB3ZXJlbid0IGluc3RhbnRpYXRlZCB5ZXQuXHJcbiAgICAgICAgaWYgKCF0aGlzLl9pc0xpc3RlbmluZykge1xyXG4gICAgICAgICAgICB0aGlzLl9pbml0TGlzdGVuZXJzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBvYnNlcnZlciBmcm9tIG9ic2VydmVycyBsaXN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7SW50ZXJzZWN0aW9uT2JzZXJ2ZXJ9IG9ic2VydmVyIC0gT2JzZXJ2ZXIgdG8gYmUgcmVtb3ZlZC5cclxuICAgICAqL1xyXG4gICAgZGlzY29ubmVjdChvYnNlcnZlcikge1xyXG4gICAgICAgIGxldCBvYnNlcnZlcnMgPSB0aGlzLl9vYnNlcnZlcnMsXHJcbiAgICAgICAgICAgIGluZGV4ID0gb2JzZXJ2ZXJzLmluZGV4T2Yob2JzZXJ2ZXIpO1xyXG5cclxuICAgICAgICBpZiAofmluZGV4KSB7XHJcbiAgICAgICAgICAgIG9ic2VydmVycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIGxpc3RlbmVycyBpZiBjb250cm9sbGVyXHJcbiAgICAgICAgLy8gaGFzIG5vIGNvbm5lY3RlZCBvYnNlcnZlcnMuXHJcbiAgICAgICAgaWYgKCFvYnNlcnZlcnMubGVuZ3RoICYmIHRoaXMuX2lzTGlzdGVuaW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZUxpc3RlbmVycygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlbGxzIHdoZXRoZXIgcHJvdmlkZWQgb2JzZXJ2ZXIgaXMgY29ubmVjdGVkIHRvIGNvbnRyb2xsZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtJbnRlcnNlY3Rpb25PYnNlcnZlcn0gb2JzZXJ2ZXIgLSBPYnNlcnZlciB0byBiZSBjaGVja2VkLlxyXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIGlzQ29ubmVjdGVkKG9ic2VydmVyKSB7XHJcbiAgICAgICAgcmV0dXJuICEhfnRoaXMuX29ic2VydmVycy5pbmRleE9mKG9ic2VydmVyKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgZXZlcnkgb2JzZXJ2ZXIgZnJvbSBvYnNlcnZlcnMgbGlzdCBhbmRcclxuICAgICAqIG5vdGlmaWVzIHRoZW0gb2YgcXVldWVkIGVudHJpZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBSZXR1cm5zIFwidHJ1ZVwiIGlmIGFueSBvYnNlcnZlclxyXG4gICAgICogICAgICBoYXMgZGV0ZWN0ZWQgY2hhbmdlcyBpbiBwb3NpdGlvbiBvZiBpdHMgZWxlbWVudHMuXHJcbiAgICAgKi9cclxuICAgIF91cGRhdGVPYnNlcnZlcnMoKSB7XHJcbiAgICAgICAgbGV0IGhhc0NoYW5nZXMgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgZm9yIChjb25zdCBvYnNlcnZlciBvZiB0aGlzLl9vYnNlcnZlcnMpIHtcclxuICAgICAgICAgICAgaWYgKG9ic2VydmVyLnVwZGF0ZU9ic2VydmF0aW9ucygpKSB7XHJcbiAgICAgICAgICAgICAgICBoYXNDaGFuZ2VzID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKG9ic2VydmVyLmhhc0VudHJpZXMoKSkge1xyXG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIubm90aWZ5U3Vic2NyaWJlcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gaGFzQ2hhbmdlcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNjaGVkdWxlcyBuZXcgdXBkYXRlIGN5Y2xlLlxyXG4gICAgICovXHJcbiAgICBzdGFydFVwZGF0ZUN5Y2xlKCkge1xyXG4gICAgICAgIHRoaXMuX2N5Y2xlU3RhcnRUaW1lID0gbm93KCk7XHJcblxyXG4gICAgICAgIHRoaXMuc2NoZWR1bGVVcGRhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnRyb2xzIGludm9jYXRpb24gb2YgXCJfdXBkYXRlT2JzZXJ2ZXJzXCIgbWV0aG9kLlxyXG4gICAgICogSXQgd2lsbCByZS1pbnZva2UgaXRzZWxmIGluIHRoZSBmb2xsb3dpbmcgY2FzZXM6XHJcbiAgICAgKiAgICAgIC0gVXBkYXRlIG9mIG9ic2VydmVycyBkZXRlY3RlZCBjaGFuZ2VzIGluIGVsZW1lbnRzIHBvc2l0aW9uLlxyXG4gICAgICogICAgICAgIEluIHRoaXMgY2FzZSB3ZSBuZWVkIHRvIHBvc3Rwb25lIGN5Y2xlIGVuZCB0aW1lIGluIG9yZGVyIHRvIGVuc3VyZVxyXG4gICAgICogICAgICAgIHRoYXQgd2Ugd29uJ3QgbWlzcyBuZXh0IGl0ZXJhdGlvbiBvZiBhbmltYXRpb25zLlxyXG4gICAgICpcclxuICAgICAqICAgICAgLSBJZGxlIHRpbWVvdXQgd2Fzbid0IHJlYWNoZWQgeWV0LlxyXG4gICAgICogICAgICAgIEluIHRoaXMgY2FzZSB3ZSBuZWVkIHRvIHNjaGVkdWxlIG5ldyBzaW5nbGUgdXBkYXRlXHJcbiAgICAgKiAgICAgICAgYmVjYXVzZSBjaGFuZ2VzIG1heSBiZSBkZWxheWVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbdGltZXN0YW1wXSAtIEludGVybmFsIHBhcmFtZXRlclxyXG4gICAgICogICAgICB0aGF0IGlzIHVzZWQgdG8gZGVmaW5lIHdoZXRoZXIgbWV0aG9kIHdhcyBpbnZva2VkXHJcbiAgICAgKiAgICAgIGFzIGEgY2FsbGJhY2sgb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLlxyXG4gICAgICovXHJcbiAgICBzY2hlZHVsZVVwZGF0ZSh0aW1lc3RhbXApIHtcclxuICAgICAgICBsZXQgY2FsbGVkRnJvbVJBRiA9IHR5cGVvZiB0aW1lc3RhbXAgPT09ICdudW1iZXInO1xyXG5cclxuICAgICAgICAvLyBJbnZva2UgdGhlIHVwZGF0ZSBvZiBvYnNlcnZlcnMgb25seSBpZiBmdW5jdGlvblxyXG4gICAgICAgIC8vIHdhcyBjYWxsZWQgYXMgYSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgY2FsbGJhY2suXHJcbiAgICAgICAgaWYgKGNhbGxlZEZyb21SQUYpIHtcclxuICAgICAgICAgICAgY29uc3QgaGFzQ2hhbmdlcyA9IHRoaXMuX3VwZGF0ZU9ic2VydmVycygpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5faXNVcGRhdGVTY2hlZHVsZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIC8vIERvIG5vdGhpbmcgaWYgY3ljbGUgd2Fzbid0IHN0YXJ0ZWQuXHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fd2FzQ3ljbGVTdGFydGVkKCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGhhc0NoYW5nZXMpIHtcclxuICAgICAgICAgICAgICAgIC8vIFBvc3Rwb25lIGN5Y2xlIGVuZCB0aW1lIGlmIGNoYW5nZXMgd2VyZSBkZXRlY3RlZC5cclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRVcGRhdGVDeWNsZSgpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9oYXNJZGxlVGltZUVuZGVkKCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFNjaGVkdWxlIG5ldyBzaW5nbGUgdXBkYXRlIGlmIGN5Y2xlIHRpbWVvdXQgd2Fzbid0IHJlYWNoZWQgeWV0LlxyXG4gICAgICAgICAgICAgICAgdGhpcy5zY2hlZHVsZVVwZGF0ZSgpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gRmluaXNoIGN5Y2xlLlxyXG4gICAgICAgICAgICAgICAgdGhpcy5fb25DeWNsZUVuZGVkKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9pc1VwZGF0ZVNjaGVkdWxlZCkge1xyXG4gICAgICAgICAgICAvLyBSZXF1ZXN0IG5ldyB1cGRhdGUgaWYgaXQgd2Fzbid0IHJlcXVlc3RlZCBhbHJlYWR5LlxyXG4gICAgICAgICAgICByZXF1ZXN0QW5pbUZyYW1lKHRoaXMuc2NoZWR1bGVVcGRhdGUpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5faXNVcGRhdGVTY2hlZHVsZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlbGxzIHdoZXRoZXIgY3ljbGUgaGFzIHJlYWNoZWQgaXRzIGlkbGUgdGltZW91dC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIF9oYXNJZGxlVGltZUVuZGVkKCkge1xyXG4gICAgICAgIHJldHVybiBub3coKSAtIHRoaXMuX2N5Y2xlU3RhcnRUaW1lID4gdGhpcy5faWRsZVRpbWVvdXQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZWxscyB3aGV0aGVyIHRoZSB1cGRhdGUgY3ljbGUgaXMgY3VycmVudGx5IHJ1bm5pbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxyXG4gICAgICovXHJcbiAgICBfd2FzQ3ljbGVTdGFydGVkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jeWNsZVN0YXJ0VGltZSAhPT0gLTE7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsYmFjayB0aGF0IHdpbGwgYmUgaW52b2tlZCBhZnRlciB0aGUgdXBkYXRlIGN5Y2xlIGlzIGZpbmlzaGVkLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIF9vbkN5Y2xlRW5kZWQoKSB7XHJcbiAgICAgICAgLy8gTWFyayB0aGF0IHVwZGF0ZSBjeWNsZSBpcyBub3QgcnVubmluZy5cclxuICAgICAgICB0aGlzLl9jeWNsZVN0YXJ0VGltZSA9IC0xO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5fcmVwZWF0Q3ljbGUpIHtcclxuICAgICAgICAgICAgLy8gVGltZSBpcyBzZXQgdG8gJzAnIGJlY2F1c2Ugd2Ugd2FudCB0byBhdXRvbWF0aWNhbGx5XHJcbiAgICAgICAgICAgIC8vIHN0YXJ0IHVwZGF0ZSBjeWNsZSB3aGVuIHNpbmdsZSB1cGRhdGUgZGV0ZWN0cyBjaGFuZ2VzLlxyXG4gICAgICAgICAgICB0aGlzLl9jeWNsZVN0YXJ0VGltZSA9IDA7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9yZXBlYXRIYW5kbGVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbGl6ZXMgRE9NIGxpc3RlbmVycy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfaW5pdExpc3RlbmVycygpIHtcclxuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIGxpc3RlbmVycyBhcmUgYWxyZWFkeSBpbml0aWF0ZWQuXHJcbiAgICAgICAgaWYgKHRoaXMuX2lzTGlzdGVuaW5nKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX2lzTGlzdGVuaW5nID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgLy8gVXNlIHVwZGF0ZSBjeWNsZSBoZXJlIGluc3RlYWQgb2YgYSBzaW5nbGUgdXBkYXRlIGJlY2F1c2Ugd2UgbWF5IGVuY291bnRlclxyXG4gICAgICAgIC8vIHdpdGggZGVsYXllZCBjaGFuZ2VzLCBlLmcuIHdoZW4gd2lkdGggb3IgaGVpZ2h0IG9mIGFuXHJcbiAgICAgICAgLy8gZWxlbWVudCBhcmUgY2hhbmdlZCBieSBDU1MgdHJhbnNpdGlvbnMuXHJcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuc3RhcnRVcGRhdGVDeWNsZSwgdHJ1ZSk7XHJcblxyXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLnNjaGVkdWxlVXBkYXRlLCB0cnVlKTtcclxuXHJcbiAgICAgICAgLy8gTGlzdGVuIHRvIHBvc3NpYmxlIGNoYW5nZXMgbWFkZSBieSBcIjpob3ZlclwiIGNsYXNzLlxyXG4gICAgICAgIGlmICh0aGlzLl90cmFja0hvdmVycykge1xyXG4gICAgICAgICAgICB0aGlzLl9hZGRIb3Zlckxpc3RlbmVyKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBGYWxsIGJhY2sgdG8gcmVwZWF0YWJsZSBjeWNsZSB3aXRoIGFkZGl0aW9uYWwgdHJhY2tpbmcgb2ZcclxuICAgICAgICAvLyBcImNsaWNrXCIgZXZlbnQgaWYgTXV0YXRpb25PYnNlcnZlciBpcyBub3Qgc3VwcG9ydGVkLlxyXG4gICAgICAgIGlmICghbXV0YXRpb25zU3VwcG9ydGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlcGVhdEN5Y2xlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIC8vIExpc3RlbiB0byBjbGlja3MgYXMgdGhleSBtYXkgY2F1c2UgY2hhbmdlcyBpbiBlbGVtZW50cyBwb3NpdGlvbi5cclxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5zdGFydFVwZGF0ZUN5Y2xlLCB0cnVlKTtcclxuXHJcbiAgICAgICAgICAgIC8vIE1hbnVhbGx5IHN0YXJ0IGN5Y2xlLlxyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0VXBkYXRlQ3ljbGUoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBTdWJzY3JpYmUgdG8gRE9NIG11dGF0aW9ucyBhcyB0aGV5IG1heSBsZWFkIHRvIGNoYW5nZXMgaW4gcG9zaXRpb24gb2YgZWxlbWVudHMuXHJcbiAgICAgICAgICAgIHRoaXMuX211dGF0aW9uc09ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIodGhpcy5fb25NdXRhdGlvbik7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9tdXRhdGlvbnNPYnNlcnZlci5vYnNlcnZlKGRvY3VtZW50LCB7XHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHN1YnRyZWU6IHRydWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhbGwgRE9NIGxpc3RlbmVycy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfcmVtb3ZlTGlzdGVuZXJzKCkge1xyXG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgbGlzdGVuZXJzIHdlcmUgYWxyZWFkeSByZW1vdmVkLlxyXG4gICAgICAgIGlmICghdGhpcy5faXNMaXN0ZW5pbmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuc3RhcnRVcGRhdGVDeWNsZSwgdHJ1ZSk7XHJcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuc2NoZWR1bGVVcGRhdGUsIHRydWUpO1xyXG5cclxuICAgICAgICB0aGlzLl9yZW1vdmVIb3Zlckxpc3RlbmVyKCk7XHJcblxyXG4gICAgICAgIGlmICghbXV0YXRpb25zU3VwcG9ydGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlcGVhdEN5Y2xlID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLnN0YXJ0VXBkYXRlQ3ljbGUsIHRydWUpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fbXV0YXRpb25zT2JzZXJ2ZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5fbXV0YXRpb25zT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xyXG4gICAgICAgICAgICB0aGlzLl9tdXRhdGlvbnNPYnNlcnZlciA9IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9pc0xpc3RlbmluZyA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRW5hYmxlcyBob3ZlciBsaXN0ZW5lci5cclxuICAgICAqL1xyXG4gICAgZW5hYmxlSG92ZXIoKSB7XHJcbiAgICAgICAgdGhpcy5fdHJhY2tIb3ZlcnMgPSB0cnVlO1xyXG5cclxuICAgICAgICAvLyBNYW51YWxseSBhZGQgaG92ZXIgbGlzdGVuZXJcclxuICAgICAgICAvLyBpZiBsaXN0ZW5lcnMgd2VyZSBhbHJlYWR5IGluaXRpYXRlZC5cclxuICAgICAgICBpZiAodGhpcy5faXNMaXN0ZW5pbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5fYWRkSG92ZXJMaXN0ZW5lcigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERpc2FibGVzIGhvdmVyIGxpc3RlbmVyLlxyXG4gICAgICovXHJcbiAgICBkaXNhYmxlSG92ZXIoKSB7XHJcbiAgICAgICAgdGhpcy5fdHJhY2tIb3ZlcnMgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgdGhpcy5fcmVtb3ZlSG92ZXJMaXN0ZW5lcigpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVsbHMgd2hldGhlciBob3ZlciBsaXN0ZW5lciBpcyBlbmFibGVkLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxyXG4gICAgICovXHJcbiAgICBpc0hvdmVyRW5hYmxlZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdHJhY2tIb3ZlcnM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIFwibW91c2VvdmVyXCIgbGlzdGVuZXIgaWYgaXQgd2Fzbid0IGFscmVhZHkgYWRkZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgX2FkZEhvdmVyTGlzdGVuZXIoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2hvdmVySW5pdGlhdGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCB0aGlzLl9vbk1vdXNlT3ZlciwgdHJ1ZSk7XHJcblxyXG4gICAgICAgIHRoaXMuX2hvdmVySW5pdGlhdGVkID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgXCJtb3VzZW92ZXJcIiBsaXN0ZW5lciBpZiBpdCB3YXMgYWRkZWQgcHJldmlvdXNseS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfcmVtb3ZlSG92ZXJMaXN0ZW5lcigpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2hvdmVySW5pdGlhdGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCB0aGlzLl9vbk1vdXNlT3ZlciwgdHJ1ZSk7XHJcblxyXG4gICAgICAgIHRoaXMuX2hvdmVySW5pdGlhdGVkID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBET00gbXV0YXRpb25zIGhhbmRsZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7QXJyYXk8TXV0YXRpb25SZWNvcmQ+fSBlbnRyaWVzXHJcbiAgICAgKi9cclxuICAgIF9vbk11dGF0aW9uKGVudHJpZXMpIHtcclxuICAgICAgICBjb25zdCBydW5TaW5nbGVVcGRhdGUgPSBlbnRyaWVzLmV2ZXJ5KGVudHJ5ID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGVudHJ5LnR5cGUgIT09ICdhdHRyaWJ1dGVzJztcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gU2NoZWR1bGUgc2luZ2xlIHVwZGF0ZSBpZiBhdHRyaWJ1dGVzIChjbGFzcywgc3R5bGUsIGV0Yy4pXHJcbiAgICAgICAgLy8gd2VyZSBub3QgY2hhbmdlZC4gT3RoZXJ3aXNlIHJ1biB1cGRhdGUgY3ljbGUgYmVjYXVzZVxyXG4gICAgICAgIC8vIGFuaW1hdGlvbnMgYXJlIGV4cGVjdGVkIHRvIGFwcGVhciBvbmx5IGluIHRoaXMgY2FzZS5cclxuICAgICAgICBydW5TaW5nbGVVcGRhdGUgP1xyXG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlVXBkYXRlKCkgOlxyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0VXBkYXRlQ3ljbGUoKTtcclxuICAgIH1cclxufVxyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/intersection-observer-polyfill/src/IntersectionObserverController.js\n')},"./node_modules/intersection-observer-polyfill/src/IntersectionObserverEntry.js":/*!**************************************************************************************!*\
  !*** ./node_modules/intersection-observer-polyfill/src/IntersectionObserverEntry.js ***!
  \**************************************************************************************//*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){'use strict';eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return IntersectionObserverEntry; });\n/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./geometry */ "./node_modules/intersection-observer-polyfill/src/geometry.js");\n\r\n\r\nclass IntersectionObserverEntry {\r\n    /**\r\n     * Creates new instance of IntersectionObserverEntry.\r\n     *\r\n     * @param {Element} target\r\n     * @param {ClientRect} targetRect\r\n     * @param {ClientRect} intersecRect\r\n     * @param {Number} intersecRatio\r\n     * @param {ClientRect} rootBounds\r\n     * @param {Timestamp} time\r\n     */\r\n    constructor(target, targetRect, intersecRect, intersecRatio, rootBounds, time) {\r\n\r\n        // According to the spec following properties are not writable and\r\n        // in native implementation they are also not enumerable.\r\n        Object.defineProperties(this, {\r\n            boundingClientRect: {value: targetRect},\r\n            intersectionRatio:  {value: intersecRatio},\r\n            intersectionRect:   {value: Object(_geometry__WEBPACK_IMPORTED_MODULE_0__["mapToClientRect"])(intersecRect)},\r\n            rootBounds:         {value: Object(_geometry__WEBPACK_IMPORTED_MODULE_0__["mapToClientRect"])(rootBounds)},\r\n            target:             {value: target},\r\n            time:               {value: time}\r\n        });\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW50ZXJzZWN0aW9uLW9ic2VydmVyLXBvbHlmaWxsL3NyYy9JbnRlcnNlY3Rpb25PYnNlcnZlckVudHJ5LmpzPzliZTciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQTJDOztBQUU1QjtBQUNmO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFdBQVc7QUFDMUIsZUFBZSxXQUFXO0FBQzFCLGVBQWUsT0FBTztBQUN0QixlQUFlLFdBQVc7QUFDMUIsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtCQUFrQjtBQUNuRCxpQ0FBaUMscUJBQXFCO0FBQ3RELGlDQUFpQyxPQUFPLGlFQUFlLGVBQWU7QUFDdEUsaUNBQWlDLE9BQU8saUVBQWUsYUFBYTtBQUNwRSxpQ0FBaUMsY0FBYztBQUMvQyxpQ0FBaUM7QUFDakMsU0FBUztBQUNUO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaW50ZXJzZWN0aW9uLW9ic2VydmVyLXBvbHlmaWxsL3NyYy9JbnRlcnNlY3Rpb25PYnNlcnZlckVudHJ5LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHttYXBUb0NsaWVudFJlY3R9IGZyb20gJy4vZ2VvbWV0cnknO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW50ZXJzZWN0aW9uT2JzZXJ2ZXJFbnRyeSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgbmV3IGluc3RhbmNlIG9mIEludGVyc2VjdGlvbk9ic2VydmVyRW50cnkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRcclxuICAgICAqIEBwYXJhbSB7Q2xpZW50UmVjdH0gdGFyZ2V0UmVjdFxyXG4gICAgICogQHBhcmFtIHtDbGllbnRSZWN0fSBpbnRlcnNlY1JlY3RcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbnRlcnNlY1JhdGlvXHJcbiAgICAgKiBAcGFyYW0ge0NsaWVudFJlY3R9IHJvb3RCb3VuZHNcclxuICAgICAqIEBwYXJhbSB7VGltZXN0YW1wfSB0aW1lXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHRhcmdldCwgdGFyZ2V0UmVjdCwgaW50ZXJzZWNSZWN0LCBpbnRlcnNlY1JhdGlvLCByb290Qm91bmRzLCB0aW1lKSB7XHJcblxyXG4gICAgICAgIC8vIEFjY29yZGluZyB0byB0aGUgc3BlYyBmb2xsb3dpbmcgcHJvcGVydGllcyBhcmUgbm90IHdyaXRhYmxlIGFuZFxyXG4gICAgICAgIC8vIGluIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiB0aGV5IGFyZSBhbHNvIG5vdCBlbnVtZXJhYmxlLlxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcclxuICAgICAgICAgICAgYm91bmRpbmdDbGllbnRSZWN0OiB7dmFsdWU6IHRhcmdldFJlY3R9LFxyXG4gICAgICAgICAgICBpbnRlcnNlY3Rpb25SYXRpbzogIHt2YWx1ZTogaW50ZXJzZWNSYXRpb30sXHJcbiAgICAgICAgICAgIGludGVyc2VjdGlvblJlY3Q6ICAge3ZhbHVlOiBtYXBUb0NsaWVudFJlY3QoaW50ZXJzZWNSZWN0KX0sXHJcbiAgICAgICAgICAgIHJvb3RCb3VuZHM6ICAgICAgICAge3ZhbHVlOiBtYXBUb0NsaWVudFJlY3Qocm9vdEJvdW5kcyl9LFxyXG4gICAgICAgICAgICB0YXJnZXQ6ICAgICAgICAgICAgIHt2YWx1ZTogdGFyZ2V0fSxcclxuICAgICAgICAgICAgdGltZTogICAgICAgICAgICAgICB7dmFsdWU6IHRpbWV9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/intersection-observer-polyfill/src/IntersectionObserverEntry.js\n')},"./node_modules/intersection-observer-polyfill/src/_IntersectionObserver.js":/*!**********************************************************************************!*\
  !*** ./node_modules/intersection-observer-polyfill/src/_IntersectionObserver.js ***!
  \**********************************************************************************//*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){'use strict';eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return IntersectionObserver; });\n/* harmony import */ var _shims_es6_collections__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shims/es6-collections */ "./node_modules/intersection-observer-polyfill/src/shims/es6-collections.js");\n/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./geometry */ "./node_modules/intersection-observer-polyfill/src/geometry.js");\n/* harmony import */ var _IntersectionObservation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./IntersectionObservation */ "./node_modules/intersection-observer-polyfill/src/IntersectionObservation.js");\n\r\n\r\n\r\n\r\n/**\r\n * Validates and parses threshold values.\r\n * Throws an error if one of the thresholds\r\n * is non-finite or not in range of 0 and 1.\r\n *\r\n * @param {(Array<Number>|Number)} [thresholds = 0]\r\n * @returns {Array<Number>} An array of thresholds in ascending order.\r\n */\r\nfunction parseThresholds(thresholds = 0) {\r\n    let result = thresholds;\r\n\r\n    if (!Array.isArray(thresholds)) {\r\n        result = [thresholds];\r\n    } else if (!thresholds.length) {\r\n        result = [0];\r\n    }\r\n\r\n    return result.map(threshold => {\r\n        // We use Number function instead of parseFloat\r\n        // to convert boolean values and null to theirs\r\n        // numeric representation. This is done to act\r\n        // in the same manner as a native implementation.\r\n        threshold = Number(threshold);\r\n\r\n        if (!window.isFinite(threshold)) {\r\n            throw new TypeError(\'The provided double value is non-finite.\');\r\n        } else if (threshold < 0 || threshold > 1) {\r\n            throw new RangeError(\'Threshold values must be between 0 and 1.\');\r\n        }\r\n\r\n        return threshold;\r\n    }).sort();\r\n}\r\n\r\n/**\r\n * Validates and converts margins value (defined in a form of\r\n * CSS \'margin\' property) to a list of tokens, e.g:\r\n * 1. \'0px\' = [[\'0px\'], [\'0px\'], [\'0px\'], [\'0px\']]\r\n * 2. \'5px 11px\' = [[\'5px\'], [\'11px\'], [\'5px\'], [\'11px\']]\r\n *\r\n * @param {String} [margins = \'0px\'] - Margins value to be processed.\r\n * @returns {Array<Array>} Object that contains both: a list of\r\n *      tokens and its string representation.\r\n */\r\nfunction parseMargins(margins = \'0px\') {\r\n    // Use regular expression in order to properly\r\n    // handle multiple spaces in-between of tokens: \'0px     2px   5px\'.\r\n    //\r\n    // Casting to a string is required to keep the behavior\r\n    // closer to the native implementation which converts\r\n    // an array like [[[\'2px 3px\']]] to \'2px 3px\';\r\n    margins = (margins + \'\').split(/\\s+/);\r\n\r\n    // Chrome validates tokens length starting from version 53.\r\n    if (margins.length > 4) {\r\n        throw new Error(\'Extra text found at the end of rootMargin.\');\r\n    }\r\n\r\n    margins[0] = margins[0] || \'0px\';\r\n    margins[1] = margins[1] || margins[0];\r\n    margins[2] = margins[2] || margins[0];\r\n    margins[3] = margins[3] || margins[1];\r\n\r\n    const rawData = margins.join(\' \');\r\n\r\n    const parsedData = margins.map(token => {\r\n        let [,value, unit] = /^(-?\\d*\\.?\\d+)(px|%)$/.exec(token) || [];\r\n        const pixels = unit === \'px\';\r\n\r\n        value = parseFloat(value);\r\n\r\n        if (!window.isFinite(value)) {\r\n            throw new Error(\'rootMargin must be specified in pixels or percent.\');\r\n        }\r\n\r\n        if (!pixels) {\r\n            value /= 100;\r\n        }\r\n\r\n        return {value, pixels};\r\n    });\r\n\r\n    return {rawData, parsedData};\r\n}\r\n\r\n/**\r\n * Creates new rectangle from provided one whose\r\n * dimensions will be modified by applying margins\r\n * defined in a form of [[value: Number, pixels: Boolean], ...].\r\n *\r\n * @param {ClientRect} targetRect - Initial rectangle.\r\n * @param {Array<Array>} margins - Margins data.\r\n * @returns {ClientRect} Modified rectangle.\r\n */\r\nfunction applyMargins(targetRect, margins) {\r\n    margins = margins.map((margin, index) => {\r\n        let value = margin.value;\r\n\r\n        if (!margin.pixels) {\r\n            value *= index % 2 ? targetRect.width : targetRect.height;\r\n        }\r\n\r\n        return value;\r\n    });\r\n\r\n    const result = {\r\n        top: targetRect.top - margins[0],\r\n        right: targetRect.right + margins[1],\r\n        bottom: targetRect.bottom + margins[2],\r\n        left: targetRect.left - margins[3]\r\n    };\r\n\r\n    result.width = result.right - result.left;\r\n    result.height = result.bottom - result.top;\r\n\r\n    return result;\r\n}\r\n\r\nclass IntersectionObserver {\r\n    /**\r\n     * Creates new IntersectionObserver instance.\r\n     *\r\n     * @param {Function} callback - Callback function that will be invoked\r\n     *      whenever one of the observed targets reaches new ratio value defined in "options.threshold".\r\n     * @param {Object} [options = {}] - Optional configuration.\r\n     * @param {IntersectionObserverController} controller - Associated controller instance.\r\n     * @param {IntersectionObserver} publicObserver - This value will be used as\r\n     *      a value of "this" binding for the callback function.\r\n     */\r\n    constructor(callback, options = {}, controller, publicObserver) {\r\n        if (typeof callback !== \'function\') {\r\n            throw new TypeError("The callback provided as parameter 1 is not a function.");\r\n        }\r\n\r\n        if (typeof options !== \'object\') {\r\n            throw new TypeError("parameter 2 is not an object.");\r\n        }\r\n\r\n        if (\'root\' in options && !(options.root instanceof Element)) {\r\n            throw new TypeError("member root is not of type Element.");\r\n        }\r\n\r\n\r\n        const thresholds = parseThresholds(options.threshold);\r\n        const rootMargin = parseMargins(options.rootMargin);\r\n\r\n        this.root = options.root || null;\r\n        this.rootMargin = rootMargin.rawData;\r\n\r\n        // Thresholds array needs to be immutable\r\n        // according to the native implementation.\r\n        this.thresholds = Object.freeze(thresholds);\r\n\r\n        this._root = options.root || document.documentElement;\r\n        this._callback = callback;\r\n        this._rootMargin = rootMargin.parsedData;\r\n\r\n        // Registry of observed elements and\r\n        // corresponding IntersectionObservation instances.\r\n        this._targets = new _shims_es6_collections__WEBPACK_IMPORTED_MODULE_0__["Map"]();\r\n\r\n        // A list of queued IntersectionObserverEntry\r\n        // items that will passed to the callback function.\r\n        this._quedEntries = [];\r\n\r\n        this._publicObserver = publicObserver || this;\r\n\r\n        this.controller = controller;\r\n    }\r\n\r\n    /**\r\n     * Adds provided target to observations list.\r\n     *\r\n     * @param {Element} target - DOM element to be observed.\r\n     */\r\n    observe(target) {\r\n        if (!arguments.length) {\r\n            throw new TypeError(\'1 argument required, but only 0 present.\');\r\n        }\r\n\r\n        if (!(target instanceof Element)) {\r\n            throw new TypeError(\'parameter 1 is not of type "Element".\');\r\n        }\r\n\r\n        let targets = this._targets;\r\n\r\n        // Do nothing if target is already observed.\r\n        if (targets.has(target)) {\r\n            return;\r\n        }\r\n\r\n        // Create new IntersectionObservation instance and assign it\r\n        // to provided target.\r\n        targets.set(target, new _IntersectionObservation__WEBPACK_IMPORTED_MODULE_2__["default"](target, this));\r\n\r\n        // Connect current observer to controller\r\n        // if it wasn\'t connected yet.\r\n        if (!this.controller.isConnected(this)) {\r\n            this.controller.connect(this);\r\n        }\r\n\r\n        // Request the update of observers.\r\n        this.controller.startUpdateCycle();\r\n    }\r\n\r\n    /**\r\n     * Removes provided target from observations list.\r\n     *\r\n     * @param {Element} target - DOM element to stop observing.\r\n     */\r\n    unobserve(target) {\r\n        if (!arguments.length) {\r\n            throw new TypeError(\'1 argument required, but only 0 present.\');\r\n        }\r\n\r\n        if (!(target instanceof Element)) {\r\n            throw new TypeError(\'parameter 1 is not of type "Element".\');\r\n        }\r\n\r\n        let targets = this._targets;\r\n\r\n        if (targets.has(target)) {\r\n            targets.delete(target);\r\n        }\r\n\r\n        // Disconnect observer if the list of observed targets is empty.\r\n        if (!targets.size) {\r\n            this.disconnect();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes all targets from observations list\r\n     * and disconnects observer from associated controller, i.e.\r\n     * no updates will be invoked for it.\r\n     */\r\n    disconnect() {\r\n        this._targets.clear();\r\n        this.controller.disconnect(this);\r\n    }\r\n\r\n    /**\r\n     * Returns a list of queued observation entries and\r\n     * clears the queue.\r\n     *\r\n     * @returns {Array}\r\n     */\r\n    takeRecords() {\r\n        return this._quedEntries.splice(0);\r\n    }\r\n\r\n    /**\r\n     * Invokes callback function with a list\r\n     * of queued entries if the last one is not empty.\r\n     *\r\n     * @private\r\n     */\r\n    notifySubscriber() {\r\n        const entries = this.takeRecords();\r\n        const publicObserver = this._publicObserver;\r\n\r\n        if (entries.length) {\r\n            this._callback.call(publicObserver, entries, publicObserver);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds entry to the queue.\r\n     *\r\n     * @param {IntersectionObserverEntry} entry\r\n     */\r\n    queueEntry(entry) {\r\n        this._quedEntries.push(entry);\r\n    }\r\n\r\n    /**\r\n     * Tells whether observer has queued entries.\r\n     *\r\n     * @returns {Boolean}\r\n     */\r\n    hasEntries() {\r\n        return !!this._quedEntries.length;\r\n    }\r\n\r\n    /**\r\n     * Updates intersection data of each observed target.\r\n     *\r\n     * @returns {Boolean} Returns "true" if intersection ratio or the rectangle of one of the\r\n     *      observed targets has changed. This information is required for\r\n     *      controller to decide whether to continue running the update cycle.\r\n     */\r\n    updateObservations() {\r\n        let root     = this._root,\r\n            rootRect = this.getRootRect(),\r\n            hasChanges = false;\r\n\r\n        this._targets.forEach(observation => {\r\n            const changes = observation.updateIntersection(root, rootRect);\r\n\r\n            if (changes.ratioChanged || changes.targetRectChanged) {\r\n                hasChanges = true;\r\n            }\r\n        });\r\n\r\n        return hasChanges;\r\n    }\r\n\r\n    /**\r\n     * Finds index of the first threshold whose value is greater than provided ratio.\r\n     * In case if there is no such value the amount of thresholds will be returned.\r\n     *\r\n     * @param {Number} ratio\r\n     * @returns {Number}\r\n     */\r\n    getThresholdGreaterThan(ratio) {\r\n        let thresholds = this.thresholds,\r\n            thresholdsLen = thresholds.length,\r\n            index = 0;\r\n\r\n        while (index < thresholdsLen && thresholds[index] <= ratio) {\r\n            ++index;\r\n        }\r\n\r\n        return index;\r\n    }\r\n\r\n    /**\r\n     * Calculates rectangle of root node with applied margins.\r\n     *\r\n     * @returns {ClientRect}\r\n     */\r\n    getRootRect() {\r\n        let rootRect = Object(_geometry__WEBPACK_IMPORTED_MODULE_1__["getRectangle"])(this._root);\r\n\r\n        return applyMargins(rootRect, this._rootMargin);\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW50ZXJzZWN0aW9uLW9ic2VydmVyLXBvbHlmaWxsL3NyYy9fSW50ZXJzZWN0aW9uT2JzZXJ2ZXIuanM/NTUzYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQTRDO0FBQ0o7QUFDd0I7O0FBRWhFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCO0FBQ2hCLEtBQUs7O0FBRUwsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxhQUFhO0FBQ3hCLGFBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQSxlQUFlLE9BQU8sY0FBYztBQUNwQyxlQUFlLCtCQUErQjtBQUM5QyxlQUFlLHFCQUFxQjtBQUNwQztBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLDBEQUFHOztBQUUvQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxnRUFBdUI7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMEJBQTBCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLHVCQUF1Qiw4REFBWTs7QUFFbkM7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2ludGVyc2VjdGlvbi1vYnNlcnZlci1wb2x5ZmlsbC9zcmMvX0ludGVyc2VjdGlvbk9ic2VydmVyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtNYXB9IGZyb20gJy4vc2hpbXMvZXM2LWNvbGxlY3Rpb25zJztcclxuaW1wb3J0IHtnZXRSZWN0YW5nbGV9IGZyb20gJy4vZ2VvbWV0cnknO1xyXG5pbXBvcnQgSW50ZXJzZWN0aW9uT2JzZXJ2YXRpb24gZnJvbSAnLi9JbnRlcnNlY3Rpb25PYnNlcnZhdGlvbic7XHJcblxyXG4vKipcclxuICogVmFsaWRhdGVzIGFuZCBwYXJzZXMgdGhyZXNob2xkIHZhbHVlcy5cclxuICogVGhyb3dzIGFuIGVycm9yIGlmIG9uZSBvZiB0aGUgdGhyZXNob2xkc1xyXG4gKiBpcyBub24tZmluaXRlIG9yIG5vdCBpbiByYW5nZSBvZiAwIGFuZCAxLlxyXG4gKlxyXG4gKiBAcGFyYW0geyhBcnJheTxOdW1iZXI+fE51bWJlcil9IFt0aHJlc2hvbGRzID0gMF1cclxuICogQHJldHVybnMge0FycmF5PE51bWJlcj59IEFuIGFycmF5IG9mIHRocmVzaG9sZHMgaW4gYXNjZW5kaW5nIG9yZGVyLlxyXG4gKi9cclxuZnVuY3Rpb24gcGFyc2VUaHJlc2hvbGRzKHRocmVzaG9sZHMgPSAwKSB7XHJcbiAgICBsZXQgcmVzdWx0ID0gdGhyZXNob2xkcztcclxuXHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodGhyZXNob2xkcykpIHtcclxuICAgICAgICByZXN1bHQgPSBbdGhyZXNob2xkc107XHJcbiAgICB9IGVsc2UgaWYgKCF0aHJlc2hvbGRzLmxlbmd0aCkge1xyXG4gICAgICAgIHJlc3VsdCA9IFswXTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzdWx0Lm1hcCh0aHJlc2hvbGQgPT4ge1xyXG4gICAgICAgIC8vIFdlIHVzZSBOdW1iZXIgZnVuY3Rpb24gaW5zdGVhZCBvZiBwYXJzZUZsb2F0XHJcbiAgICAgICAgLy8gdG8gY29udmVydCBib29sZWFuIHZhbHVlcyBhbmQgbnVsbCB0byB0aGVpcnNcclxuICAgICAgICAvLyBudW1lcmljIHJlcHJlc2VudGF0aW9uLiBUaGlzIGlzIGRvbmUgdG8gYWN0XHJcbiAgICAgICAgLy8gaW4gdGhlIHNhbWUgbWFubmVyIGFzIGEgbmF0aXZlIGltcGxlbWVudGF0aW9uLlxyXG4gICAgICAgIHRocmVzaG9sZCA9IE51bWJlcih0aHJlc2hvbGQpO1xyXG5cclxuICAgICAgICBpZiAoIXdpbmRvdy5pc0Zpbml0ZSh0aHJlc2hvbGQpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBwcm92aWRlZCBkb3VibGUgdmFsdWUgaXMgbm9uLWZpbml0ZS4nKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHRocmVzaG9sZCA8IDAgfHwgdGhyZXNob2xkID4gMSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhyZXNob2xkIHZhbHVlcyBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMS4nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aHJlc2hvbGQ7XHJcbiAgICB9KS5zb3J0KCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBWYWxpZGF0ZXMgYW5kIGNvbnZlcnRzIG1hcmdpbnMgdmFsdWUgKGRlZmluZWQgaW4gYSBmb3JtIG9mXHJcbiAqIENTUyAnbWFyZ2luJyBwcm9wZXJ0eSkgdG8gYSBsaXN0IG9mIHRva2VucywgZS5nOlxyXG4gKiAxLiAnMHB4JyA9IFtbJzBweCddLCBbJzBweCddLCBbJzBweCddLCBbJzBweCddXVxyXG4gKiAyLiAnNXB4IDExcHgnID0gW1snNXB4J10sIFsnMTFweCddLCBbJzVweCddLCBbJzExcHgnXV1cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IFttYXJnaW5zID0gJzBweCddIC0gTWFyZ2lucyB2YWx1ZSB0byBiZSBwcm9jZXNzZWQuXHJcbiAqIEByZXR1cm5zIHtBcnJheTxBcnJheT59IE9iamVjdCB0aGF0IGNvbnRhaW5zIGJvdGg6IGEgbGlzdCBvZlxyXG4gKiAgICAgIHRva2VucyBhbmQgaXRzIHN0cmluZyByZXByZXNlbnRhdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIHBhcnNlTWFyZ2lucyhtYXJnaW5zID0gJzBweCcpIHtcclxuICAgIC8vIFVzZSByZWd1bGFyIGV4cHJlc3Npb24gaW4gb3JkZXIgdG8gcHJvcGVybHlcclxuICAgIC8vIGhhbmRsZSBtdWx0aXBsZSBzcGFjZXMgaW4tYmV0d2VlbiBvZiB0b2tlbnM6ICcwcHggICAgIDJweCAgIDVweCcuXHJcbiAgICAvL1xyXG4gICAgLy8gQ2FzdGluZyB0byBhIHN0cmluZyBpcyByZXF1aXJlZCB0byBrZWVwIHRoZSBiZWhhdmlvclxyXG4gICAgLy8gY2xvc2VyIHRvIHRoZSBuYXRpdmUgaW1wbGVtZW50YXRpb24gd2hpY2ggY29udmVydHNcclxuICAgIC8vIGFuIGFycmF5IGxpa2UgW1tbJzJweCAzcHgnXV1dIHRvICcycHggM3B4JztcclxuICAgIG1hcmdpbnMgPSAobWFyZ2lucyArICcnKS5zcGxpdCgvXFxzKy8pO1xyXG5cclxuICAgIC8vIENocm9tZSB2YWxpZGF0ZXMgdG9rZW5zIGxlbmd0aCBzdGFydGluZyBmcm9tIHZlcnNpb24gNTMuXHJcbiAgICBpZiAobWFyZ2lucy5sZW5ndGggPiA0KSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHRyYSB0ZXh0IGZvdW5kIGF0IHRoZSBlbmQgb2Ygcm9vdE1hcmdpbi4nKTtcclxuICAgIH1cclxuXHJcbiAgICBtYXJnaW5zWzBdID0gbWFyZ2luc1swXSB8fCAnMHB4JztcclxuICAgIG1hcmdpbnNbMV0gPSBtYXJnaW5zWzFdIHx8IG1hcmdpbnNbMF07XHJcbiAgICBtYXJnaW5zWzJdID0gbWFyZ2luc1syXSB8fCBtYXJnaW5zWzBdO1xyXG4gICAgbWFyZ2luc1szXSA9IG1hcmdpbnNbM10gfHwgbWFyZ2luc1sxXTtcclxuXHJcbiAgICBjb25zdCByYXdEYXRhID0gbWFyZ2lucy5qb2luKCcgJyk7XHJcblxyXG4gICAgY29uc3QgcGFyc2VkRGF0YSA9IG1hcmdpbnMubWFwKHRva2VuID0+IHtcclxuICAgICAgICBsZXQgWyx2YWx1ZSwgdW5pdF0gPSAvXigtP1xcZCpcXC4/XFxkKykocHh8JSkkLy5leGVjKHRva2VuKSB8fCBbXTtcclxuICAgICAgICBjb25zdCBwaXhlbHMgPSB1bml0ID09PSAncHgnO1xyXG5cclxuICAgICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xyXG5cclxuICAgICAgICBpZiAoIXdpbmRvdy5pc0Zpbml0ZSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyb290TWFyZ2luIG11c3QgYmUgc3BlY2lmaWVkIGluIHBpeGVscyBvciBwZXJjZW50LicpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFwaXhlbHMpIHtcclxuICAgICAgICAgICAgdmFsdWUgLz0gMTAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHt2YWx1ZSwgcGl4ZWxzfTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB7cmF3RGF0YSwgcGFyc2VkRGF0YX07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIG5ldyByZWN0YW5nbGUgZnJvbSBwcm92aWRlZCBvbmUgd2hvc2VcclxuICogZGltZW5zaW9ucyB3aWxsIGJlIG1vZGlmaWVkIGJ5IGFwcGx5aW5nIG1hcmdpbnNcclxuICogZGVmaW5lZCBpbiBhIGZvcm0gb2YgW1t2YWx1ZTogTnVtYmVyLCBwaXhlbHM6IEJvb2xlYW5dLCAuLi5dLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0NsaWVudFJlY3R9IHRhcmdldFJlY3QgLSBJbml0aWFsIHJlY3RhbmdsZS5cclxuICogQHBhcmFtIHtBcnJheTxBcnJheT59IG1hcmdpbnMgLSBNYXJnaW5zIGRhdGEuXHJcbiAqIEByZXR1cm5zIHtDbGllbnRSZWN0fSBNb2RpZmllZCByZWN0YW5nbGUuXHJcbiAqL1xyXG5mdW5jdGlvbiBhcHBseU1hcmdpbnModGFyZ2V0UmVjdCwgbWFyZ2lucykge1xyXG4gICAgbWFyZ2lucyA9IG1hcmdpbnMubWFwKChtYXJnaW4sIGluZGV4KSA9PiB7XHJcbiAgICAgICAgbGV0IHZhbHVlID0gbWFyZ2luLnZhbHVlO1xyXG5cclxuICAgICAgICBpZiAoIW1hcmdpbi5waXhlbHMpIHtcclxuICAgICAgICAgICAgdmFsdWUgKj0gaW5kZXggJSAyID8gdGFyZ2V0UmVjdC53aWR0aCA6IHRhcmdldFJlY3QuaGVpZ2h0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgcmVzdWx0ID0ge1xyXG4gICAgICAgIHRvcDogdGFyZ2V0UmVjdC50b3AgLSBtYXJnaW5zWzBdLFxyXG4gICAgICAgIHJpZ2h0OiB0YXJnZXRSZWN0LnJpZ2h0ICsgbWFyZ2luc1sxXSxcclxuICAgICAgICBib3R0b206IHRhcmdldFJlY3QuYm90dG9tICsgbWFyZ2luc1syXSxcclxuICAgICAgICBsZWZ0OiB0YXJnZXRSZWN0LmxlZnQgLSBtYXJnaW5zWzNdXHJcbiAgICB9O1xyXG5cclxuICAgIHJlc3VsdC53aWR0aCA9IHJlc3VsdC5yaWdodCAtIHJlc3VsdC5sZWZ0O1xyXG4gICAgcmVzdWx0LmhlaWdodCA9IHJlc3VsdC5ib3R0b20gLSByZXN1bHQudG9wO1xyXG5cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEludGVyc2VjdGlvbk9ic2VydmVyIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgaW5zdGFuY2UuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBDYWxsYmFjayBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgaW52b2tlZFxyXG4gICAgICogICAgICB3aGVuZXZlciBvbmUgb2YgdGhlIG9ic2VydmVkIHRhcmdldHMgcmVhY2hlcyBuZXcgcmF0aW8gdmFsdWUgZGVmaW5lZCBpbiBcIm9wdGlvbnMudGhyZXNob2xkXCIuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMgPSB7fV0gLSBPcHRpb25hbCBjb25maWd1cmF0aW9uLlxyXG4gICAgICogQHBhcmFtIHtJbnRlcnNlY3Rpb25PYnNlcnZlckNvbnRyb2xsZXJ9IGNvbnRyb2xsZXIgLSBBc3NvY2lhdGVkIGNvbnRyb2xsZXIgaW5zdGFuY2UuXHJcbiAgICAgKiBAcGFyYW0ge0ludGVyc2VjdGlvbk9ic2VydmVyfSBwdWJsaWNPYnNlcnZlciAtIFRoaXMgdmFsdWUgd2lsbCBiZSB1c2VkIGFzXHJcbiAgICAgKiAgICAgIGEgdmFsdWUgb2YgXCJ0aGlzXCIgYmluZGluZyBmb3IgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihjYWxsYmFjaywgb3B0aW9ucyA9IHt9LCBjb250cm9sbGVyLCBwdWJsaWNPYnNlcnZlcikge1xyXG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBjYWxsYmFjayBwcm92aWRlZCBhcyBwYXJhbWV0ZXIgMSBpcyBub3QgYSBmdW5jdGlvbi5cIik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJwYXJhbWV0ZXIgMiBpcyBub3QgYW4gb2JqZWN0LlwiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICgncm9vdCcgaW4gb3B0aW9ucyAmJiAhKG9wdGlvbnMucm9vdCBpbnN0YW5jZW9mIEVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJtZW1iZXIgcm9vdCBpcyBub3Qgb2YgdHlwZSBFbGVtZW50LlwiKTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICBjb25zdCB0aHJlc2hvbGRzID0gcGFyc2VUaHJlc2hvbGRzKG9wdGlvbnMudGhyZXNob2xkKTtcclxuICAgICAgICBjb25zdCByb290TWFyZ2luID0gcGFyc2VNYXJnaW5zKG9wdGlvbnMucm9vdE1hcmdpbik7XHJcblxyXG4gICAgICAgIHRoaXMucm9vdCA9IG9wdGlvbnMucm9vdCB8fCBudWxsO1xyXG4gICAgICAgIHRoaXMucm9vdE1hcmdpbiA9IHJvb3RNYXJnaW4ucmF3RGF0YTtcclxuXHJcbiAgICAgICAgLy8gVGhyZXNob2xkcyBhcnJheSBuZWVkcyB0byBiZSBpbW11dGFibGVcclxuICAgICAgICAvLyBhY2NvcmRpbmcgdG8gdGhlIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbi5cclxuICAgICAgICB0aGlzLnRocmVzaG9sZHMgPSBPYmplY3QuZnJlZXplKHRocmVzaG9sZHMpO1xyXG5cclxuICAgICAgICB0aGlzLl9yb290ID0gb3B0aW9ucy5yb290IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcclxuICAgICAgICB0aGlzLl9jYWxsYmFjayA9IGNhbGxiYWNrO1xyXG4gICAgICAgIHRoaXMuX3Jvb3RNYXJnaW4gPSByb290TWFyZ2luLnBhcnNlZERhdGE7XHJcblxyXG4gICAgICAgIC8vIFJlZ2lzdHJ5IG9mIG9ic2VydmVkIGVsZW1lbnRzIGFuZFxyXG4gICAgICAgIC8vIGNvcnJlc3BvbmRpbmcgSW50ZXJzZWN0aW9uT2JzZXJ2YXRpb24gaW5zdGFuY2VzLlxyXG4gICAgICAgIHRoaXMuX3RhcmdldHMgPSBuZXcgTWFwKCk7XHJcblxyXG4gICAgICAgIC8vIEEgbGlzdCBvZiBxdWV1ZWQgSW50ZXJzZWN0aW9uT2JzZXJ2ZXJFbnRyeVxyXG4gICAgICAgIC8vIGl0ZW1zIHRoYXQgd2lsbCBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxyXG4gICAgICAgIHRoaXMuX3F1ZWRFbnRyaWVzID0gW107XHJcblxyXG4gICAgICAgIHRoaXMuX3B1YmxpY09ic2VydmVyID0gcHVibGljT2JzZXJ2ZXIgfHwgdGhpcztcclxuXHJcbiAgICAgICAgdGhpcy5jb250cm9sbGVyID0gY29udHJvbGxlcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgcHJvdmlkZWQgdGFyZ2V0IHRvIG9ic2VydmF0aW9ucyBsaXN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRE9NIGVsZW1lbnQgdG8gYmUgb2JzZXJ2ZWQuXHJcbiAgICAgKi9cclxuICAgIG9ic2VydmUodGFyZ2V0KSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5IDAgcHJlc2VudC4nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghKHRhcmdldCBpbnN0YW5jZW9mIEVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3BhcmFtZXRlciAxIGlzIG5vdCBvZiB0eXBlIFwiRWxlbWVudFwiLicpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHRhcmdldHMgPSB0aGlzLl90YXJnZXRzO1xyXG5cclxuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIHRhcmdldCBpcyBhbHJlYWR5IG9ic2VydmVkLlxyXG4gICAgICAgIGlmICh0YXJnZXRzLmhhcyh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENyZWF0ZSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2YXRpb24gaW5zdGFuY2UgYW5kIGFzc2lnbiBpdFxyXG4gICAgICAgIC8vIHRvIHByb3ZpZGVkIHRhcmdldC5cclxuICAgICAgICB0YXJnZXRzLnNldCh0YXJnZXQsIG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZhdGlvbih0YXJnZXQsIHRoaXMpKTtcclxuXHJcbiAgICAgICAgLy8gQ29ubmVjdCBjdXJyZW50IG9ic2VydmVyIHRvIGNvbnRyb2xsZXJcclxuICAgICAgICAvLyBpZiBpdCB3YXNuJ3QgY29ubmVjdGVkIHlldC5cclxuICAgICAgICBpZiAoIXRoaXMuY29udHJvbGxlci5pc0Nvbm5lY3RlZCh0aGlzKSkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xsZXIuY29ubmVjdCh0aGlzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlcXVlc3QgdGhlIHVwZGF0ZSBvZiBvYnNlcnZlcnMuXHJcbiAgICAgICAgdGhpcy5jb250cm9sbGVyLnN0YXJ0VXBkYXRlQ3ljbGUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgcHJvdmlkZWQgdGFyZ2V0IGZyb20gb2JzZXJ2YXRpb25zIGxpc3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgLSBET00gZWxlbWVudCB0byBzdG9wIG9ic2VydmluZy5cclxuICAgICAqL1xyXG4gICAgdW5vYnNlcnZlKHRhcmdldCkge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAwIHByZXNlbnQuJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoISh0YXJnZXQgaW5zdGFuY2VvZiBFbGVtZW50KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXJhbWV0ZXIgMSBpcyBub3Qgb2YgdHlwZSBcIkVsZW1lbnRcIi4nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCB0YXJnZXRzID0gdGhpcy5fdGFyZ2V0cztcclxuXHJcbiAgICAgICAgaWYgKHRhcmdldHMuaGFzKHRhcmdldCkpIHtcclxuICAgICAgICAgICAgdGFyZ2V0cy5kZWxldGUodGFyZ2V0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERpc2Nvbm5lY3Qgb2JzZXJ2ZXIgaWYgdGhlIGxpc3Qgb2Ygb2JzZXJ2ZWQgdGFyZ2V0cyBpcyBlbXB0eS5cclxuICAgICAgICBpZiAoIXRhcmdldHMuc2l6ZSkge1xyXG4gICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGFsbCB0YXJnZXRzIGZyb20gb2JzZXJ2YXRpb25zIGxpc3RcclxuICAgICAqIGFuZCBkaXNjb25uZWN0cyBvYnNlcnZlciBmcm9tIGFzc29jaWF0ZWQgY29udHJvbGxlciwgaS5lLlxyXG4gICAgICogbm8gdXBkYXRlcyB3aWxsIGJlIGludm9rZWQgZm9yIGl0LlxyXG4gICAgICovXHJcbiAgICBkaXNjb25uZWN0KCkge1xyXG4gICAgICAgIHRoaXMuX3RhcmdldHMuY2xlYXIoKTtcclxuICAgICAgICB0aGlzLmNvbnRyb2xsZXIuZGlzY29ubmVjdCh0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIHF1ZXVlZCBvYnNlcnZhdGlvbiBlbnRyaWVzIGFuZFxyXG4gICAgICogY2xlYXJzIHRoZSBxdWV1ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAgICAgKi9cclxuICAgIHRha2VSZWNvcmRzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9xdWVkRW50cmllcy5zcGxpY2UoMCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnZva2VzIGNhbGxiYWNrIGZ1bmN0aW9uIHdpdGggYSBsaXN0XHJcbiAgICAgKiBvZiBxdWV1ZWQgZW50cmllcyBpZiB0aGUgbGFzdCBvbmUgaXMgbm90IGVtcHR5LlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIG5vdGlmeVN1YnNjcmliZXIoKSB7XHJcbiAgICAgICAgY29uc3QgZW50cmllcyA9IHRoaXMudGFrZVJlY29yZHMoKTtcclxuICAgICAgICBjb25zdCBwdWJsaWNPYnNlcnZlciA9IHRoaXMuX3B1YmxpY09ic2VydmVyO1xyXG5cclxuICAgICAgICBpZiAoZW50cmllcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2suY2FsbChwdWJsaWNPYnNlcnZlciwgZW50cmllcywgcHVibGljT2JzZXJ2ZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgZW50cnkgdG8gdGhlIHF1ZXVlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7SW50ZXJzZWN0aW9uT2JzZXJ2ZXJFbnRyeX0gZW50cnlcclxuICAgICAqL1xyXG4gICAgcXVldWVFbnRyeShlbnRyeSkge1xyXG4gICAgICAgIHRoaXMuX3F1ZWRFbnRyaWVzLnB1c2goZW50cnkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVsbHMgd2hldGhlciBvYnNlcnZlciBoYXMgcXVldWVkIGVudHJpZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIGhhc0VudHJpZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fcXVlZEVudHJpZXMubGVuZ3RoO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyBpbnRlcnNlY3Rpb24gZGF0YSBvZiBlYWNoIG9ic2VydmVkIHRhcmdldC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gUmV0dXJucyBcInRydWVcIiBpZiBpbnRlcnNlY3Rpb24gcmF0aW8gb3IgdGhlIHJlY3RhbmdsZSBvZiBvbmUgb2YgdGhlXHJcbiAgICAgKiAgICAgIG9ic2VydmVkIHRhcmdldHMgaGFzIGNoYW5nZWQuIFRoaXMgaW5mb3JtYXRpb24gaXMgcmVxdWlyZWQgZm9yXHJcbiAgICAgKiAgICAgIGNvbnRyb2xsZXIgdG8gZGVjaWRlIHdoZXRoZXIgdG8gY29udGludWUgcnVubmluZyB0aGUgdXBkYXRlIGN5Y2xlLlxyXG4gICAgICovXHJcbiAgICB1cGRhdGVPYnNlcnZhdGlvbnMoKSB7XHJcbiAgICAgICAgbGV0IHJvb3QgICAgID0gdGhpcy5fcm9vdCxcclxuICAgICAgICAgICAgcm9vdFJlY3QgPSB0aGlzLmdldFJvb3RSZWN0KCksXHJcbiAgICAgICAgICAgIGhhc0NoYW5nZXMgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgdGhpcy5fdGFyZ2V0cy5mb3JFYWNoKG9ic2VydmF0aW9uID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY2hhbmdlcyA9IG9ic2VydmF0aW9uLnVwZGF0ZUludGVyc2VjdGlvbihyb290LCByb290UmVjdCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoY2hhbmdlcy5yYXRpb0NoYW5nZWQgfHwgY2hhbmdlcy50YXJnZXRSZWN0Q2hhbmdlZCkge1xyXG4gICAgICAgICAgICAgICAgaGFzQ2hhbmdlcyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGhhc0NoYW5nZXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5kcyBpbmRleCBvZiB0aGUgZmlyc3QgdGhyZXNob2xkIHdob3NlIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiBwcm92aWRlZCByYXRpby5cclxuICAgICAqIEluIGNhc2UgaWYgdGhlcmUgaXMgbm8gc3VjaCB2YWx1ZSB0aGUgYW1vdW50IG9mIHRocmVzaG9sZHMgd2lsbCBiZSByZXR1cm5lZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmF0aW9cclxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGdldFRocmVzaG9sZEdyZWF0ZXJUaGFuKHJhdGlvKSB7XHJcbiAgICAgICAgbGV0IHRocmVzaG9sZHMgPSB0aGlzLnRocmVzaG9sZHMsXHJcbiAgICAgICAgICAgIHRocmVzaG9sZHNMZW4gPSB0aHJlc2hvbGRzLmxlbmd0aCxcclxuICAgICAgICAgICAgaW5kZXggPSAwO1xyXG5cclxuICAgICAgICB3aGlsZSAoaW5kZXggPCB0aHJlc2hvbGRzTGVuICYmIHRocmVzaG9sZHNbaW5kZXhdIDw9IHJhdGlvKSB7XHJcbiAgICAgICAgICAgICsraW5kZXg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gaW5kZXg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIHJlY3RhbmdsZSBvZiByb290IG5vZGUgd2l0aCBhcHBsaWVkIG1hcmdpbnMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge0NsaWVudFJlY3R9XHJcbiAgICAgKi9cclxuICAgIGdldFJvb3RSZWN0KCkge1xyXG4gICAgICAgIGxldCByb290UmVjdCA9IGdldFJlY3RhbmdsZSh0aGlzLl9yb290KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGFwcGx5TWFyZ2lucyhyb290UmVjdCwgdGhpcy5fcm9vdE1hcmdpbik7XHJcbiAgICB9XHJcbn1cclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/intersection-observer-polyfill/src/_IntersectionObserver.js\n')},"./node_modules/intersection-observer-polyfill/src/geometry.js":/*!*********************************************************************!*\
  !*** ./node_modules/intersection-observer-polyfill/src/geometry.js ***!
  \*********************************************************************//*! exports provided: mapToClientRect, createRectangle, getRectangle, getArea, isEmpty, isEqual */function(module,__webpack_exports__,__webpack_require__){'use strict';eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mapToClientRect", function() { return mapToClientRect; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createRectangle", function() { return createRectangle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRectangle", function() { return getRectangle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getArea", function() { return getArea; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isEmpty", function() { return isEmpty; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isEqual", function() { return isEqual; });\n/**\r\n * From provided rectangle creates a new one whose\r\n * properties are not enumerable, configurable or writable.\r\n *\r\n * @param {ClientRect} rect - Initial rectangle.\r\n * @returns {ClientRect}\r\n */\r\nfunction mapToClientRect(rect) {\r\n    const descriptors = {};\r\n\r\n    for (const key of Object.keys(rect)) {\r\n        descriptors[key] = {value: rect[key]};\r\n    }\r\n\r\n    return Object.defineProperties({}, descriptors);\r\n}\r\n\r\n/**\r\n * Creates rectangle based on provided arguments.\r\n * If called without arguments then an empty rectangle\r\n * will be created.\r\n *\r\n * @param {Number} [left = 0] - Left position of rectangle.\r\n * @param {Number} [top = 0] - Top position of rectangle.\r\n * @param {Number} [width = 0] - Rectangles\' width.\r\n * @param {Number} [height = 0] - Rectangles\' height.\r\n * @returns {ClientRect}\r\n */\r\nfunction createRectangle(left = 0, top = 0, width = 0, height = 0) {\r\n    return {\r\n        left, top, width, height,\r\n        bottom: top + height,\r\n        right: left + width\r\n    };\r\n}\r\n\r\n/**\r\n * Returns client rectangle of provided element.\r\n * If element represents documentElement then returns\r\n * main viewport rectangle.\r\n *\r\n * @param {Element} target\r\n * @returns {ClientRect}\r\n */\r\nfunction getRectangle(target) {\r\n    if (target === document.documentElement) {\r\n        return createRectangle(0, 0, target.clientWidth, target.clientHeight);\r\n    }\r\n\r\n    return target.getBoundingClientRect();\r\n}\r\n\r\n/**\r\n * Calculates area of rectangle.\r\n *\r\n * @param {ClientRect} rect - Rectangle whose area needs to be calculated.\r\n * @returns {Number} Rectangles\' area.\r\n */\r\nfunction getArea(rect) {\r\n    return rect.width * rect.height;\r\n}\r\n\r\n/**\r\n * Tells whether rectangle is empty.\r\n *\r\n * @param {ClientRect} rect - Rectangle to be checked.\r\n * @returns {Boolean}\r\n */\r\nfunction isEmpty(rect) {\r\n    return rect.height === 0 && rect.width === 0;\r\n}\r\n\r\n/**\r\n * Compares rectangles to each other.\r\n *\r\n * @param {ClientRect} first\r\n * @param {ClientRect} second\r\n * @returns {Boolean}\r\n */\r\nfunction isEqual(first, second) {\r\n    return (\r\n        first.top === second.top &&\r\n        first.left === second.left &&\r\n        first.right === second.right &&\r\n        first.bottom === second.bottom\r\n    );\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW50ZXJzZWN0aW9uLW9ic2VydmVyLXBvbHlmaWxsL3NyYy9nZW9tZXRyeS5qcz9iMTM4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsYUFBYTtBQUNiO0FBQ087QUFDUDs7QUFFQTtBQUNBLDRCQUE0QjtBQUM1Qjs7QUFFQSxxQ0FBcUM7QUFDckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLGFBQWEsT0FBTztBQUNwQjtBQUNPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsYUFBYTtBQUNiO0FBQ087QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixXQUFXLFdBQVc7QUFDdEIsYUFBYTtBQUNiO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9pbnRlcnNlY3Rpb24tb2JzZXJ2ZXItcG9seWZpbGwvc3JjL2dlb21ldHJ5LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIEZyb20gcHJvdmlkZWQgcmVjdGFuZ2xlIGNyZWF0ZXMgYSBuZXcgb25lIHdob3NlXHJcbiAqIHByb3BlcnRpZXMgYXJlIG5vdCBlbnVtZXJhYmxlLCBjb25maWd1cmFibGUgb3Igd3JpdGFibGUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Q2xpZW50UmVjdH0gcmVjdCAtIEluaXRpYWwgcmVjdGFuZ2xlLlxyXG4gKiBAcmV0dXJucyB7Q2xpZW50UmVjdH1cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBtYXBUb0NsaWVudFJlY3QocmVjdCkge1xyXG4gICAgY29uc3QgZGVzY3JpcHRvcnMgPSB7fTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhyZWN0KSkge1xyXG4gICAgICAgIGRlc2NyaXB0b3JzW2tleV0gPSB7dmFsdWU6IHJlY3Rba2V5XX07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHt9LCBkZXNjcmlwdG9ycyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIHJlY3RhbmdsZSBiYXNlZCBvbiBwcm92aWRlZCBhcmd1bWVudHMuXHJcbiAqIElmIGNhbGxlZCB3aXRob3V0IGFyZ3VtZW50cyB0aGVuIGFuIGVtcHR5IHJlY3RhbmdsZVxyXG4gKiB3aWxsIGJlIGNyZWF0ZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbbGVmdCA9IDBdIC0gTGVmdCBwb3NpdGlvbiBvZiByZWN0YW5nbGUuXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbdG9wID0gMF0gLSBUb3AgcG9zaXRpb24gb2YgcmVjdGFuZ2xlLlxyXG4gKiBAcGFyYW0ge051bWJlcn0gW3dpZHRoID0gMF0gLSBSZWN0YW5nbGVzJyB3aWR0aC5cclxuICogQHBhcmFtIHtOdW1iZXJ9IFtoZWlnaHQgPSAwXSAtIFJlY3RhbmdsZXMnIGhlaWdodC5cclxuICogQHJldHVybnMge0NsaWVudFJlY3R9XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUmVjdGFuZ2xlKGxlZnQgPSAwLCB0b3AgPSAwLCB3aWR0aCA9IDAsIGhlaWdodCA9IDApIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0LFxyXG4gICAgICAgIGJvdHRvbTogdG9wICsgaGVpZ2h0LFxyXG4gICAgICAgIHJpZ2h0OiBsZWZ0ICsgd2lkdGhcclxuICAgIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGNsaWVudCByZWN0YW5nbGUgb2YgcHJvdmlkZWQgZWxlbWVudC5cclxuICogSWYgZWxlbWVudCByZXByZXNlbnRzIGRvY3VtZW50RWxlbWVudCB0aGVuIHJldHVybnNcclxuICogbWFpbiB2aWV3cG9ydCByZWN0YW5nbGUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0XHJcbiAqIEByZXR1cm5zIHtDbGllbnRSZWN0fVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFJlY3RhbmdsZSh0YXJnZXQpIHtcclxuICAgIGlmICh0YXJnZXQgPT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVSZWN0YW5nbGUoMCwgMCwgdGFyZ2V0LmNsaWVudFdpZHRoLCB0YXJnZXQuY2xpZW50SGVpZ2h0KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG59XHJcblxyXG4vKipcclxuICogQ2FsY3VsYXRlcyBhcmVhIG9mIHJlY3RhbmdsZS5cclxuICpcclxuICogQHBhcmFtIHtDbGllbnRSZWN0fSByZWN0IC0gUmVjdGFuZ2xlIHdob3NlIGFyZWEgbmVlZHMgdG8gYmUgY2FsY3VsYXRlZC5cclxuICogQHJldHVybnMge051bWJlcn0gUmVjdGFuZ2xlcycgYXJlYS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRBcmVhKHJlY3QpIHtcclxuICAgIHJldHVybiByZWN0LndpZHRoICogcmVjdC5oZWlnaHQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUZWxscyB3aGV0aGVyIHJlY3RhbmdsZSBpcyBlbXB0eS5cclxuICpcclxuICogQHBhcmFtIHtDbGllbnRSZWN0fSByZWN0IC0gUmVjdGFuZ2xlIHRvIGJlIGNoZWNrZWQuXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzRW1wdHkocmVjdCkge1xyXG4gICAgcmV0dXJuIHJlY3QuaGVpZ2h0ID09PSAwICYmIHJlY3Qud2lkdGggPT09IDA7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb21wYXJlcyByZWN0YW5nbGVzIHRvIGVhY2ggb3RoZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Q2xpZW50UmVjdH0gZmlyc3RcclxuICogQHBhcmFtIHtDbGllbnRSZWN0fSBzZWNvbmRcclxuICogQHJldHVybnMge0Jvb2xlYW59XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNFcXVhbChmaXJzdCwgc2Vjb25kKSB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIGZpcnN0LnRvcCA9PT0gc2Vjb25kLnRvcCAmJlxyXG4gICAgICAgIGZpcnN0LmxlZnQgPT09IHNlY29uZC5sZWZ0ICYmXHJcbiAgICAgICAgZmlyc3QucmlnaHQgPT09IHNlY29uZC5yaWdodCAmJlxyXG4gICAgICAgIGZpcnN0LmJvdHRvbSA9PT0gc2Vjb25kLmJvdHRvbVxyXG4gICAgKTtcclxufVxyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/intersection-observer-polyfill/src/geometry.js\n')},"./node_modules/intersection-observer-polyfill/src/shims/es6-collections.js":/*!**********************************************************************************!*\
  !*** ./node_modules/intersection-observer-polyfill/src/shims/es6-collections.js ***!
  \**********************************************************************************//*! exports provided: Map, WeakMap */function(module,__webpack_exports__,__webpack_require__){'use strict';eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Map", function() { return Map; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WeakMap", function() { return WeakMap; });\n/**\r\n * Simple shims for WeakMap and Map classes.\r\n * This implementation is not meant to be used outside of IntersectionObserver modules\r\n * because it covers only limited range of use cases.\r\n */\r\n\r\nconst hasNativeCollections =\r\n    typeof window.WeakMap === \'function\' &&\r\n    typeof window.Map === \'function\';\r\n\r\nconst WeakMap = (function () {\r\n    if (hasNativeCollections) {\r\n        return window.WeakMap;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {Array<Array>} arr\r\n     * @param {Object} key\r\n     * @returns {Number}\r\n     */\r\n    function getIndex(arr, key) {\r\n        let result = -1;\r\n\r\n        arr.some((entry, index) => {\r\n            let matches = entry[0] === key;\r\n\r\n            if (matches) {\r\n                result = index;\r\n            }\r\n\r\n            return matches;\r\n        });\r\n\r\n        return result;\r\n    }\r\n\r\n    return class {\r\n        constructor() {\r\n            this.__entries__ = [];\r\n        }\r\n\r\n        /**\r\n         *\r\n         * @param {Object} key\r\n         * @returns {*}\r\n         */\r\n        get(key) {\r\n            let index = getIndex(this.__entries__, key);\r\n\r\n            return this.__entries__[index][1];\r\n        }\r\n\r\n        /**\r\n         *\r\n         * @param {Object} key\r\n         * @param {*} value\r\n         */\r\n        set(key, value) {\r\n            let index = getIndex(this.__entries__, key);\r\n\r\n            if (~index) {\r\n                this.__entries__[index][1] = value;\r\n            } else {\r\n                this.__entries__.push([key, value]);\r\n            }\r\n        }\r\n\r\n        /**\r\n         *\r\n         * @param {Object} key\r\n         */\r\n        delete(key) {\r\n            let entries = this.__entries__,\r\n                index = getIndex(entries, key);\r\n\r\n            if (~index) {\r\n                entries.splice(index, 1);\r\n            }\r\n        }\r\n\r\n        /**\r\n         *\r\n         * @param {Object} key\r\n         * @returns {Boolean}\r\n         */\r\n        has(key) {\r\n            return !!~getIndex(this.__entries__, key);\r\n        }\r\n    };\r\n})();\r\n\r\nconst Map = (function () {\r\n    if (hasNativeCollections) {\r\n        return window.Map;\r\n    }\r\n\r\n    return class extends WeakMap {\r\n        /**\r\n         *\r\n         * @returns {Number}\r\n         */\r\n        get size() {\r\n            return this.__entries__.length;\r\n        }\r\n\r\n        clear() {\r\n            this.__entries__.splice(0, this.__entries__.length);\r\n        }\r\n\r\n        /**\r\n         *\r\n         * @returns {Array<Array>}\r\n         */\r\n        entries() {\r\n            return this.__entries__.slice();\r\n        }\r\n\r\n        /**\r\n         *\r\n         * @returns {Array}\r\n         */\r\n        keys() {\r\n            return this.__entries__.map(entry => entry[0]);\r\n        }\r\n\r\n        /**\r\n         *\r\n         * @returns {Array}\r\n         */\r\n        values() {\r\n            return this.__entries__.map(entry => entry[1]);\r\n        }\r\n\r\n        /**\r\n         *\r\n         * @param {Function} callback\r\n         * @param {Object} [ctx = null]\r\n         */\r\n        forEach(callback, ctx = null) {\r\n            for (const entry of this.__entries__) {\r\n                callback.call(ctx, entry[1], entry[0]);\r\n            }\r\n        }\r\n    };\r\n})();\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW50ZXJzZWN0aW9uLW9ic2VydmVyLXBvbHlmaWxsL3NyYy9zaGltcy9lczYtY29sbGVjdGlvbnMuanM/NTY2YSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixxQkFBcUI7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixFQUFFO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QixtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaW50ZXJzZWN0aW9uLW9ic2VydmVyLXBvbHlmaWxsL3NyYy9zaGltcy9lczYtY29sbGVjdGlvbnMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogU2ltcGxlIHNoaW1zIGZvciBXZWFrTWFwIGFuZCBNYXAgY2xhc3Nlcy5cclxuICogVGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgbWVhbnQgdG8gYmUgdXNlZCBvdXRzaWRlIG9mIEludGVyc2VjdGlvbk9ic2VydmVyIG1vZHVsZXNcclxuICogYmVjYXVzZSBpdCBjb3ZlcnMgb25seSBsaW1pdGVkIHJhbmdlIG9mIHVzZSBjYXNlcy5cclxuICovXHJcblxyXG5jb25zdCBoYXNOYXRpdmVDb2xsZWN0aW9ucyA9XHJcbiAgICB0eXBlb2Ygd2luZG93LldlYWtNYXAgPT09ICdmdW5jdGlvbicgJiZcclxuICAgIHR5cGVvZiB3aW5kb3cuTWFwID09PSAnZnVuY3Rpb24nO1xyXG5cclxuY29uc3QgV2Vha01hcCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAoaGFzTmF0aXZlQ29sbGVjdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gd2luZG93LldlYWtNYXA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtBcnJheTxBcnJheT59IGFyclxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGtleVxyXG4gICAgICogQHJldHVybnMge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0SW5kZXgoYXJyLCBrZXkpIHtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gLTE7XHJcblxyXG4gICAgICAgIGFyci5zb21lKChlbnRyeSwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgbGV0IG1hdGNoZXMgPSBlbnRyeVswXSA9PT0ga2V5O1xyXG5cclxuICAgICAgICAgICAgaWYgKG1hdGNoZXMpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGluZGV4O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlcztcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY2xhc3Mge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9fZW50cmllc19fID0gW107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBrZXlcclxuICAgICAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQoa2V5KSB7XHJcbiAgICAgICAgICAgIGxldCBpbmRleCA9IGdldEluZGV4KHRoaXMuX19lbnRyaWVzX18sIGtleSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fX2VudHJpZXNfX1tpbmRleF1bMV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBrZXlcclxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2V0KGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgbGV0IGluZGV4ID0gZ2V0SW5kZXgodGhpcy5fX2VudHJpZXNfXywga2V5KTtcclxuXHJcbiAgICAgICAgICAgIGlmICh+aW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19lbnRyaWVzX19baW5kZXhdWzFdID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fZW50cmllc19fLnB1c2goW2tleSwgdmFsdWVdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0ga2V5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZGVsZXRlKGtleSkge1xyXG4gICAgICAgICAgICBsZXQgZW50cmllcyA9IHRoaXMuX19lbnRyaWVzX18sXHJcbiAgICAgICAgICAgICAgICBpbmRleCA9IGdldEluZGV4KGVudHJpZXMsIGtleSk7XHJcblxyXG4gICAgICAgICAgICBpZiAofmluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICBlbnRyaWVzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGtleVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGhhcyhrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuICEhfmdldEluZGV4KHRoaXMuX19lbnRyaWVzX18sIGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufSkoKTtcclxuXHJcbmNvbnN0IE1hcCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAoaGFzTmF0aXZlQ29sbGVjdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gd2luZG93Lk1hcDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY2xhc3MgZXh0ZW5kcyBXZWFrTWFwIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0IHNpemUoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fZW50cmllc19fLmxlbmd0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNsZWFyKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9fZW50cmllc19fLnNwbGljZSgwLCB0aGlzLl9fZW50cmllc19fLmxlbmd0aCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtBcnJheTxBcnJheT59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZW50cmllcygpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19lbnRyaWVzX18uc2xpY2UoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybnMge0FycmF5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGtleXMoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fZW50cmllc19fLm1hcChlbnRyeSA9PiBlbnRyeVswXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtBcnJheX1cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YWx1ZXMoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fZW50cmllc19fLm1hcChlbnRyeSA9PiBlbnRyeVsxXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtjdHggPSBudWxsXVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZvckVhY2goY2FsbGJhY2ssIGN0eCA9IG51bGwpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiB0aGlzLl9fZW50cmllc19fKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKGN0eCwgZW50cnlbMV0sIGVudHJ5WzBdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn0pKCk7XHJcblxyXG5leHBvcnQge01hcCwgV2Vha01hcH07Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/intersection-observer-polyfill/src/shims/es6-collections.js\n')},"./node_modules/intersection-observer-polyfill/src/shims/performance.now.js":/*!**********************************************************************************!*\
  !*** ./node_modules/intersection-observer-polyfill/src/shims/performance.now.js ***!
  \**********************************************************************************//*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){'use strict';eval('__webpack_require__.r(__webpack_exports__);\n/**\r\n * A shim for performance.now method which falls back\r\n * to Date.now if the first one is not supported.\r\n *\r\n * @returns {Timestamp}\r\n */\r\n/* harmony default export */ __webpack_exports__["default"] = ((function () {\r\n    if (window.performance && window.performance.now) {\r\n        return () => window.performance.now();\r\n    }\r\n\r\n    return () => Date.now();\r\n})());//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW50ZXJzZWN0aW9uLW9ic2VydmVyLXBvbHlmaWxsL3NyYy9zaGltcy9wZXJmb3JtYW5jZS5ub3cuanM/OGRkNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ2U7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDLEdBQUciLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaW50ZXJzZWN0aW9uLW9ic2VydmVyLXBvbHlmaWxsL3NyYy9zaGltcy9wZXJmb3JtYW5jZS5ub3cuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQSBzaGltIGZvciBwZXJmb3JtYW5jZS5ub3cgbWV0aG9kIHdoaWNoIGZhbGxzIGJhY2tcclxuICogdG8gRGF0ZS5ub3cgaWYgdGhlIGZpcnN0IG9uZSBpcyBub3Qgc3VwcG9ydGVkLlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7VGltZXN0YW1wfVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh3aW5kb3cucGVyZm9ybWFuY2UgJiYgd2luZG93LnBlcmZvcm1hbmNlLm5vdykge1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuICgpID0+IERhdGUubm93KCk7XHJcbn0pKCk7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/intersection-observer-polyfill/src/shims/performance.now.js\n')},"./src/js/index.js":/*!*************************!*\
  !*** ./src/js/index.js ***!
  \*************************//*! no static exports found */function(module,exports,__webpack_require__){'use strict';eval('\n\nvar _smoothScroll = __webpack_require__(/*! ./smoothScroll */ "./src/js/smoothScroll.js");\n\nvar _smoothScroll2 = _interopRequireDefault(_smoothScroll);\n\nvar _rellax = __webpack_require__(/*! ./rellax */ "./src/js/rellax.js");\n\nvar _rellax2 = _interopRequireDefault(_rellax);\n\nvar _intersectionObserver = __webpack_require__(/*! ./intersectionObserver */ "./src/js/intersectionObserver.js");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n// import { productObserver } from \'./productObserver\';\n\nvar jumpLinks = document.querySelectorAll(\'.js-smooth-jump-link\');\n\n[].concat(_toConsumableArray(jumpLinks)).forEach(function (el) {\n  el.addEventListener(\'click\', function (e) {\n    var pageFragmentToScrollTo = e.target.getAttribute(\'href\');\n    var elementToScrollTo = document.querySelector(pageFragmentToScrollTo);\n\n    (0, _smoothScroll2.default)(elementToScrollTo, 700, \'easeOutQuint\');\n  });\n});\n\n(0, _rellax2.default)();\n(0, _intersectionObserver.observer)();\n// productObserver();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvaW5kZXguanM/N2JhNSJdLCJuYW1lcyI6WyJqdW1wTGlua3MiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJmb3JFYWNoIiwiZWwiLCJhZGRFdmVudExpc3RlbmVyIiwiZSIsInBhZ2VGcmFnbWVudFRvU2Nyb2xsVG8iLCJ0YXJnZXQiLCJnZXRBdHRyaWJ1dGUiLCJlbGVtZW50VG9TY3JvbGxUbyIsInF1ZXJ5U2VsZWN0b3IiXSwibWFwcGluZ3MiOiI7O0FBQUE7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7QUFDQTs7QUFFQSxJQUFNQSxZQUFZQyxTQUFTQyxnQkFBVCxDQUEwQixzQkFBMUIsQ0FBbEI7O0FBRUEsNkJBQUlGLFNBQUosR0FBZUcsT0FBZixDQUF1QixVQUFDQyxFQUFELEVBQVE7QUFDN0JBLEtBQUdDLGdCQUFILENBQW9CLE9BQXBCLEVBQTZCLFVBQUNDLENBQUQsRUFBTztBQUNsQyxRQUFNQyx5QkFBeUJELEVBQUVFLE1BQUYsQ0FBU0MsWUFBVCxDQUFzQixNQUF0QixDQUEvQjtBQUNBLFFBQU1DLG9CQUFvQlQsU0FBU1UsYUFBVCxDQUF1Qkosc0JBQXZCLENBQTFCOztBQUVBLGdDQUNFRyxpQkFERixFQUVFLEdBRkYsRUFHRSxjQUhGO0FBS0QsR0FURDtBQVVELENBWEQ7O0FBYUE7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vc3JjL2pzL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHNtb290aFNjcm9sbCBmcm9tICcuL3Ntb290aFNjcm9sbCc7XG5pbXBvcnQgbXlSZWxsYXggZnJvbSAnLi9yZWxsYXgnO1xuaW1wb3J0IHsgb2JzZXJ2ZXIgfSBmcm9tICcuL2ludGVyc2VjdGlvbk9ic2VydmVyJztcbi8vIGltcG9ydCB7IHByb2R1Y3RPYnNlcnZlciB9IGZyb20gJy4vcHJvZHVjdE9ic2VydmVyJztcblxuY29uc3QganVtcExpbmtzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmpzLXNtb290aC1qdW1wLWxpbmsnKTtcblxuWy4uLmp1bXBMaW5rc10uZm9yRWFjaCgoZWwpID0+IHtcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xuICAgIGNvbnN0IHBhZ2VGcmFnbWVudFRvU2Nyb2xsVG8gPSBlLnRhcmdldC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKTtcbiAgICBjb25zdCBlbGVtZW50VG9TY3JvbGxUbyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IocGFnZUZyYWdtZW50VG9TY3JvbGxUbyk7XG5cbiAgICBzbW9vdGhTY3JvbGwoXG4gICAgICBlbGVtZW50VG9TY3JvbGxUbyxcbiAgICAgIDcwMCxcbiAgICAgICdlYXNlT3V0UXVpbnQnLFxuICAgICk7XG4gIH0pO1xufSk7XG5cbm15UmVsbGF4KCk7XG5vYnNlcnZlcigpO1xuLy8gcHJvZHVjdE9ic2VydmVyKCk7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/js/index.js\n')},"./src/js/intersectionObserver.js":/*!****************************************!*\
  !*** ./src/js/intersectionObserver.js ***!
  \****************************************//*! no static exports found */function(module,exports,__webpack_require__){'use strict';eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.observer = observer;\n\nvar _intersectionObserverPolyfill = __webpack_require__(/*! intersection-observer-polyfill */ "./node_modules/intersection-observer-polyfill/index.js");\n\nvar _intersectionObserverPolyfill2 = _interopRequireDefault(_intersectionObserverPolyfill);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar browserCutsTheMustard = function browserCutsTheMustard() {\n  return true;\n  return !!window.IntersectionObserver;\n};\n\nfunction observe() {\n  var observees = document.querySelectorAll(\'.paws\');\n\n  var observer = new _intersectionObserverPolyfill2.default(function (entries) {\n    entries.forEach(function (entry) {\n      if (entry.intersectionRatio > 0) {\n        console.log(entry.intersectionRatio);\n        entry.target.classList.add(\'animate\');\n      }\n    });\n  });\n\n  observees.forEach(function (observee) {\n    observer.observe(observee);\n  });\n}\n\nfunction observer() {\n  if (browserCutsTheMustard()) {\n    observe();\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvaW50ZXJzZWN0aW9uT2JzZXJ2ZXIuanM/N2I1OSJdLCJuYW1lcyI6WyJvYnNlcnZlciIsImJyb3dzZXJDdXRzVGhlTXVzdGFyZCIsIndpbmRvdyIsIkludGVyc2VjdGlvbk9ic2VydmVyIiwib2JzZXJ2ZSIsIm9ic2VydmVlcyIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvckFsbCIsImVudHJpZXMiLCJmb3JFYWNoIiwiZW50cnkiLCJpbnRlcnNlY3Rpb25SYXRpbyIsImNvbnNvbGUiLCJsb2ciLCJ0YXJnZXQiLCJjbGFzc0xpc3QiLCJhZGQiLCJvYnNlcnZlZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7UUF3QmdCQSxRLEdBQUFBLFE7O0FBeEJoQjs7Ozs7O0FBRUEsSUFBTUMsd0JBQXdCLFNBQXhCQSxxQkFBd0IsR0FBTTtBQUNsQyxTQUFPLElBQVA7QUFDQSxTQUFPLENBQUMsQ0FBQ0MsT0FBT0Msb0JBQWhCO0FBQ0QsQ0FIRDs7QUFLQSxTQUFTQyxPQUFULEdBQW1CO0FBQ2pCLE1BQU1DLFlBQVlDLFNBQVNDLGdCQUFULENBQTBCLE9BQTFCLENBQWxCOztBQUVBLE1BQU1QLFdBQVcsSUFBSUcsc0NBQUosQ0FBeUIsbUJBQVc7QUFDbkRLLFlBQVFDLE9BQVIsQ0FBZ0IsaUJBQVM7QUFDdkIsVUFBSUMsTUFBTUMsaUJBQU4sR0FBMEIsQ0FBOUIsRUFBaUM7QUFDL0JDLGdCQUFRQyxHQUFSLENBQVlILE1BQU1DLGlCQUFsQjtBQUNBRCxjQUFNSSxNQUFOLENBQWFDLFNBQWIsQ0FBdUJDLEdBQXZCLENBQTJCLFNBQTNCO0FBQ0Q7QUFDRixLQUxEO0FBTUQsR0FQZ0IsQ0FBakI7O0FBU0FYLFlBQVVJLE9BQVYsQ0FBa0Isb0JBQVk7QUFDNUJULGFBQVNJLE9BQVQsQ0FBaUJhLFFBQWpCO0FBQ0QsR0FGRDtBQUdEOztBQUVNLFNBQVNqQixRQUFULEdBQW9CO0FBQ3pCLE1BQUlDLHVCQUFKLEVBQTZCO0FBQzNCRztBQUNEO0FBQ0YiLCJmaWxlIjoiLi9zcmMvanMvaW50ZXJzZWN0aW9uT2JzZXJ2ZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgZnJvbSAnaW50ZXJzZWN0aW9uLW9ic2VydmVyLXBvbHlmaWxsJztcblxuY29uc3QgYnJvd3NlckN1dHNUaGVNdXN0YXJkID0gKCkgPT4ge1xuICByZXR1cm4gdHJ1ZVxuICByZXR1cm4gISF3aW5kb3cuSW50ZXJzZWN0aW9uT2JzZXJ2ZXJcbn07XG5cbmZ1bmN0aW9uIG9ic2VydmUoKSB7XG4gIGNvbnN0IG9ic2VydmVlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5wYXdzJyk7XG5cbiAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgZW50cmllcy5mb3JFYWNoKGVudHJ5ID0+IHtcbiAgICAgIGlmIChlbnRyeS5pbnRlcnNlY3Rpb25SYXRpbyA+IDApIHtcbiAgICAgICAgY29uc29sZS5sb2coZW50cnkuaW50ZXJzZWN0aW9uUmF0aW8pO1xuICAgICAgICBlbnRyeS50YXJnZXQuY2xhc3NMaXN0LmFkZCgnYW5pbWF0ZScpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBvYnNlcnZlZXMuZm9yRWFjaChvYnNlcnZlZSA9PiB7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShvYnNlcnZlZSk7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb2JzZXJ2ZXIoKSB7XG4gIGlmIChicm93c2VyQ3V0c1RoZU11c3RhcmQoKSkge1xuICAgIG9ic2VydmUoKTtcbiAgfVxufSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/js/intersectionObserver.js\n')},"./src/js/rellax.js":/*!**************************!*\
  !*** ./src/js/rellax.js ***!
  \**************************//*! no static exports found */function(module,exports,__webpack_require__){'use strict';eval('var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };\n\nexports.myRellax = myRellax;\n\n// ------------------------------------------\n// Rellax.js\n// Buttery smooth parallax library\n// Copyright (c) 2016 Moe Amaya (@moeamaya)\n// MIT license\n//\n// Thanks to Paraxify.js and Jaime Cabllero\n// for parallax concepts\n// ------------------------------------------\n\nfunction myRellax() {\n  var rellax = new Rellax(\'.rellax\', { center: true });\n}\n\n(function (root, factory) {\n  if (true) {\n    // AMD. Register as an anonymous module.\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(undefined, function () {\n  var Rellax = function Rellax(el, options) {\n    "use strict";\n\n    var self = Object.create(Rellax.prototype);\n\n    var posY = 0;\n    var screenY = 0;\n    var posX = 0;\n    var screenX = 0;\n    var blocks = [];\n    var pause = true;\n\n    // check what requestAnimationFrame to use, and if\n    // it\'s not supported, use the onscroll event\n    var loop = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame || function (callback) {\n      setTimeout(callback, 1000 / 60);\n    };\n\n    // check which transform property to use\n    var transformProp = window.transformProp || function () {\n      var testEl = document.createElement(\'div\');\n      if (testEl.style.transform === null) {\n        var vendors = [\'Webkit\', \'Moz\', \'ms\'];\n        for (var vendor in vendors) {\n          if (testEl.style[vendors[vendor] + \'Transform\'] !== undefined) {\n            return vendors[vendor] + \'Transform\';\n          }\n        }\n      }\n      return \'transform\';\n    }();\n\n    // Default Settings\n    self.options = {\n      speed: -2,\n      center: false,\n      wrapper: null,\n      relativeToWrapper: false,\n      round: true,\n      vertical: true,\n      horizontal: false,\n      callback: function callback() {}\n    };\n\n    // User defined options (might have more in the future)\n    if (options) {\n      Object.keys(options).forEach(function (key) {\n        self.options[key] = options[key];\n      });\n    }\n\n    // By default, rellax class\n    if (!el) {\n      el = \'.rellax\';\n    }\n\n    // check if el is a className or a node\n    var elements = typeof el === \'string\' ? document.querySelectorAll(el) : [el];\n\n    // Now query selector\n    if (elements.length > 0) {\n      self.elems = elements;\n    }\n\n    // The elements don\'t exist\n    else {\n        throw new Error("The elements you\'re trying to select don\'t exist.");\n      }\n\n    // Has a wrapper and it exists\n    if (self.options.wrapper) {\n      if (!self.options.wrapper.nodeType) {\n        var wrapper = document.querySelector(self.options.wrapper);\n\n        if (wrapper) {\n          self.options.wrapper = wrapper;\n        } else {\n          throw new Error("The wrapper you\'re trying to use don\'t exist.");\n        }\n      }\n    }\n\n    // Get and cache initial position of all elements\n    var cacheBlocks = function cacheBlocks() {\n      for (var i = 0; i < self.elems.length; i++) {\n        var block = createBlock(self.elems[i]);\n        blocks.push(block);\n      }\n    };\n\n    // Let\'s kick this script off\n    // Build array for cached element values\n    var init = function init() {\n      for (var i = 0; i < blocks.length; i++) {\n        self.elems[i].style.cssText = blocks[i].style;\n      }\n\n      blocks = [];\n\n      screenY = window.innerHeight;\n      screenX = window.innerWidth;\n      setPosition();\n\n      cacheBlocks();\n\n      // If paused, unpause and set listener for window resizing events\n      if (pause) {\n        window.addEventListener(\'resize\', init);\n        pause = false;\n      }\n      animate();\n    };\n\n    // We want to cache the parallax blocks\'\n    // values: base, top, height, speed\n    // el: is dom object, return: el cache values\n    var createBlock = function createBlock(el) {\n      var dataPercentage = el.getAttribute(\'data-rellax-percentage\');\n      var dataSpeed = el.getAttribute(\'data-rellax-speed\');\n      var dataZindex = el.getAttribute(\'data-rellax-zindex\') || 0;\n\n      // initializing at scrollY = 0 (top of browser), scrollX = 0 (left of browser)\n      // ensures elements are positioned based on HTML layout.\n      //\n      // If the element has the percentage attribute, the posY and posX needs to be\n      // the current scroll position\'s value, so that the elements are still positioned based on HTML layout\n      var wrapperPosY = self.options.wrapper ? self.options.wrapper.scrollTop : window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;\n      // If the option relativeToWrapper is true, use the wrappers offset to top, subtracted from the current page scroll.\n      if (self.options.relativeToWrapper) {\n        var scrollPosY = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;\n        wrapperPosY = scrollPosY - self.options.wrapper.offsetTop;\n      }\n      var posY = self.options.vertical ? dataPercentage || self.options.center ? wrapperPosY : 0 : 0;\n      var posX = self.options.horizontal ? dataPercentage || self.options.center ? window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft : 0 : 0;\n\n      var blockTop = posY + el.getBoundingClientRect().top;\n      var blockHeight = el.clientHeight || el.offsetHeight || el.scrollHeight;\n\n      var blockLeft = posX + el.getBoundingClientRect().left;\n      var blockWidth = el.clientWidth || el.offsetWidth || el.scrollWidth;\n\n      // apparently parallax equation everyone uses\n      var percentageY = dataPercentage ? dataPercentage : (posY - blockTop + screenY) / (blockHeight + screenY);\n      var percentageX = dataPercentage ? dataPercentage : (posX - blockLeft + screenX) / (blockWidth + screenX);\n      if (self.options.center) {\n        percentageX = 0.5;percentageY = 0.5;\n      }\n\n      // Optional individual block speed as data attr, otherwise global speed\n      var speed = dataSpeed ? dataSpeed : self.options.speed;\n\n      var bases = updatePosition(percentageX, percentageY, speed);\n\n      // ~~Store non-translate3d transforms~~\n      // Store inline styles and extract transforms\n      var style = el.style.cssText;\n      var transform = \'\';\n\n      // Check if there\'s an inline styled transform\n      if (style.indexOf(\'transform\') >= 0) {\n        // Get the index of the transform\n        var index = style.indexOf(\'transform\');\n\n        // Trim the style to the transform point and get the following semi-colon index\n        var trimmedStyle = style.slice(index);\n        var delimiter = trimmedStyle.indexOf(\';\');\n\n        // Remove "transform" string and save the attribute\n        if (delimiter) {\n          transform = " " + trimmedStyle.slice(11, delimiter).replace(/\\s/g, \'\');\n        } else {\n          transform = " " + trimmedStyle.slice(11).replace(/\\s/g, \'\');\n        }\n      }\n\n      return {\n        baseX: bases.x,\n        baseY: bases.y,\n        top: blockTop,\n        left: blockLeft,\n        height: blockHeight,\n        width: blockWidth,\n        speed: speed,\n        style: style,\n        transform: transform,\n        zindex: dataZindex\n      };\n    };\n\n    // set scroll position (posY, posX)\n    // side effect method is not ideal, but okay for now\n    // returns true if the scroll changed, false if nothing happened\n    var setPosition = function setPosition() {\n      var oldY = posY;\n      var oldX = posX;\n\n      posY = self.options.wrapper ? self.options.wrapper.scrollTop : (document.documentElement || document.body.parentNode || document.body).scrollTop || window.pageYOffset;\n      posX = self.options.wrapper ? self.options.wrapper.scrollLeft : (document.documentElement || document.body.parentNode || document.body).scrollLeft || window.pageXOffset;\n      // If option relativeToWrapper is true, use relative wrapper value instead.\n      if (self.options.relativeToWrapper) {\n        var scrollPosY = (document.documentElement || document.body.parentNode || document.body).scrollTop || window.pageYOffset;\n        posY = scrollPosY - self.options.wrapper.offsetTop;\n      }\n\n      if (oldY != posY && self.options.vertical) {\n        // scroll changed, return true\n        return true;\n      }\n\n      if (oldX != posX && self.options.horizontal) {\n        // scroll changed, return true\n        return true;\n      }\n\n      // scroll did not change\n      return false;\n    };\n\n    // Ahh a pure function, gets new transform value\n    // based on scrollPosition and speed\n    // Allow for decimal pixel values\n    var updatePosition = function updatePosition(percentageX, percentageY, speed) {\n      var result = {};\n      var valueX = speed * (100 * (1 - percentageX));\n      var valueY = speed * (100 * (1 - percentageY));\n\n      result.x = self.options.round ? Math.round(valueX) : Math.round(valueX * 100) / 100;\n      result.y = self.options.round ? Math.round(valueY) : Math.round(valueY * 100) / 100;\n\n      return result;\n    };\n\n    // Loop\n    var update = function update() {\n      if (setPosition() && pause === false) {\n        animate();\n      }\n\n      // loop again\n      loop(update);\n    };\n\n    // Transform3d on parallax element\n    var animate = function animate() {\n      var positions;\n      for (var i = 0; i < self.elems.length; i++) {\n        var percentageY = (posY - blocks[i].top + screenY) / (blocks[i].height + screenY);\n        var percentageX = (posX - blocks[i].left + screenX) / (blocks[i].width + screenX);\n\n        // Subtracting initialize value, so element stays in same spot as HTML\n        positions = updatePosition(percentageX, percentageY, blocks[i].speed); // - blocks[i].baseX;\n        var positionY = positions.y - blocks[i].baseY;\n        var positionX = positions.x - blocks[i].baseX;\n\n        var zindex = blocks[i].zindex;\n\n        // Move that element\n        // (Set the new translation and append initial inline transforms.)\n        var translate = \'translate3d(\' + (self.options.horizontal ? positionX : \'0\') + \'px,\' + (self.options.vertical ? positionY : \'0\') + \'px,\' + zindex + \'px) \' + blocks[i].transform;\n        self.elems[i].style[transformProp] = translate;\n      }\n      self.options.callback(positions);\n    };\n\n    self.destroy = function () {\n      for (var i = 0; i < self.elems.length; i++) {\n        self.elems[i].style.cssText = blocks[i].style;\n      }\n\n      // Remove resize event listener if not pause, and pause\n      if (!pause) {\n        window.removeEventListener(\'resize\', init);\n        pause = true;\n      }\n    };\n\n    // Init\n    init();\n\n    // Start the loop\n    update();\n\n    // Allow to recalculate the initial values whenever we want\n    self.refresh = init;\n\n    return self;\n  };\n  return Rellax;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvcmVsbGF4LmpzPzEzNjgiXSwibmFtZXMiOlsibXlSZWxsYXgiLCJyZWxsYXgiLCJSZWxsYXgiLCJjZW50ZXIiLCJyb290IiwiZmFjdG9yeSIsImRlZmluZSIsImVsIiwib3B0aW9ucyIsInNlbGYiLCJPYmplY3QiLCJjcmVhdGUiLCJwcm90b3R5cGUiLCJwb3NZIiwic2NyZWVuWSIsInBvc1giLCJzY3JlZW5YIiwiYmxvY2tzIiwicGF1c2UiLCJsb29wIiwid2luZG93IiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwid2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJvUmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiY2FsbGJhY2siLCJzZXRUaW1lb3V0IiwidHJhbnNmb3JtUHJvcCIsInRlc3RFbCIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsInN0eWxlIiwidHJhbnNmb3JtIiwidmVuZG9ycyIsInZlbmRvciIsInVuZGVmaW5lZCIsInNwZWVkIiwid3JhcHBlciIsInJlbGF0aXZlVG9XcmFwcGVyIiwicm91bmQiLCJ2ZXJ0aWNhbCIsImhvcml6b250YWwiLCJrZXlzIiwiZm9yRWFjaCIsImtleSIsImVsZW1lbnRzIiwicXVlcnlTZWxlY3RvckFsbCIsImxlbmd0aCIsImVsZW1zIiwiRXJyb3IiLCJub2RlVHlwZSIsInF1ZXJ5U2VsZWN0b3IiLCJjYWNoZUJsb2NrcyIsImkiLCJibG9jayIsImNyZWF0ZUJsb2NrIiwicHVzaCIsImluaXQiLCJjc3NUZXh0IiwiaW5uZXJIZWlnaHQiLCJpbm5lcldpZHRoIiwic2V0UG9zaXRpb24iLCJhZGRFdmVudExpc3RlbmVyIiwiYW5pbWF0ZSIsImRhdGFQZXJjZW50YWdlIiwiZ2V0QXR0cmlidXRlIiwiZGF0YVNwZWVkIiwiZGF0YVppbmRleCIsIndyYXBwZXJQb3NZIiwic2Nyb2xsVG9wIiwicGFnZVlPZmZzZXQiLCJkb2N1bWVudEVsZW1lbnQiLCJib2R5Iiwic2Nyb2xsUG9zWSIsIm9mZnNldFRvcCIsInBhZ2VYT2Zmc2V0Iiwic2Nyb2xsTGVmdCIsImJsb2NrVG9wIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwidG9wIiwiYmxvY2tIZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJvZmZzZXRIZWlnaHQiLCJzY3JvbGxIZWlnaHQiLCJibG9ja0xlZnQiLCJsZWZ0IiwiYmxvY2tXaWR0aCIsImNsaWVudFdpZHRoIiwib2Zmc2V0V2lkdGgiLCJzY3JvbGxXaWR0aCIsInBlcmNlbnRhZ2VZIiwicGVyY2VudGFnZVgiLCJiYXNlcyIsInVwZGF0ZVBvc2l0aW9uIiwiaW5kZXhPZiIsImluZGV4IiwidHJpbW1lZFN0eWxlIiwic2xpY2UiLCJkZWxpbWl0ZXIiLCJyZXBsYWNlIiwiYmFzZVgiLCJ4IiwiYmFzZVkiLCJ5IiwiaGVpZ2h0Iiwid2lkdGgiLCJ6aW5kZXgiLCJvbGRZIiwib2xkWCIsInBhcmVudE5vZGUiLCJyZXN1bHQiLCJ2YWx1ZVgiLCJ2YWx1ZVkiLCJNYXRoIiwidXBkYXRlIiwicG9zaXRpb25zIiwicG9zaXRpb25ZIiwicG9zaXRpb25YIiwidHJhbnNsYXRlIiwiZGVzdHJveSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJyZWZyZXNoIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztRQVdnQkEsUSxHQUFBQSxROztBQVZoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU8sU0FBU0EsUUFBVCxHQUFvQjtBQUN6QixNQUFJQyxTQUFTLElBQUlDLE1BQUosQ0FBVyxTQUFYLEVBQXNCLEVBQUVDLFFBQVEsSUFBVixFQUF0QixDQUFiO0FBQ0Q7O0FBRUEsV0FBVUMsSUFBVixFQUFnQkMsT0FBaEIsRUFBeUI7QUFDeEIsTUFBSSxJQUFKLEVBQWdEO0FBQzlDO0FBQ0FDLElBQUEsaUNBQU8sRUFBUCxvQ0FBV0QsT0FBWDtBQUFBO0FBQUE7QUFBQTtBQUNELEdB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LEVBQVVyQixTQUF2SztBQUNBeEIsYUFBS3dDLEtBQUwsQ0FBV0ssQ0FBWCxFQUFjdEIsS0FBZCxDQUFvQkosYUFBcEIsSUFBcUMyRixTQUFyQztBQUNEO0FBQ0Q5RyxXQUFLRCxPQUFMLENBQWFrQixRQUFiLENBQXNCMEYsU0FBdEI7QUFDRCxLQW5CRDs7QUFxQkEzRyxTQUFLK0csT0FBTCxHQUFlLFlBQVc7QUFDeEIsV0FBSyxJQUFJbEUsSUFBSSxDQUFiLEVBQWdCQSxJQUFJN0MsS0FBS3dDLEtBQUwsQ0FBV0QsTUFBL0IsRUFBdUNNLEdBQXZDLEVBQTJDO0FBQ3pDN0MsYUFBS3dDLEtBQUwsQ0FBV0ssQ0FBWCxFQUFjdEIsS0FBZCxDQUFvQjJCLE9BQXBCLEdBQThCMUMsT0FBT3FDLENBQVAsRUFBVXRCLEtBQXhDO0FBQ0Q7O0FBRUQ7QUFDQSxVQUFJLENBQUNkLEtBQUwsRUFBWTtBQUNWRSxlQUFPcUcsbUJBQVAsQ0FBMkIsUUFBM0IsRUFBcUMvRCxJQUFyQztBQUNBeEMsZ0JBQVEsSUFBUjtBQUNEO0FBQ0YsS0FWRDs7QUFZQTtBQUNBd0M7O0FBRUE7QUFDQXlEOztBQUVBO0FBQ0ExRyxTQUFLaUgsT0FBTCxHQUFlaEUsSUFBZjs7QUFFQSxXQUFPakQsSUFBUDtBQUNELEdBbFNEO0FBbVNBLFNBQU9QLE1BQVA7QUFDRCxDQWxUQSxDQUFEIiwiZmlsZSI6Ii4vc3JjL2pzL3JlbGxheC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBSZWxsYXguanNcbi8vIEJ1dHRlcnkgc21vb3RoIHBhcmFsbGF4IGxpYnJhcnlcbi8vIENvcHlyaWdodCAoYykgMjAxNiBNb2UgQW1heWEgKEBtb2VhbWF5YSlcbi8vIE1JVCBsaWNlbnNlXG4vL1xuLy8gVGhhbmtzIHRvIFBhcmF4aWZ5LmpzIGFuZCBKYWltZSBDYWJsbGVyb1xuLy8gZm9yIHBhcmFsbGF4IGNvbmNlcHRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGZ1bmN0aW9uIG15UmVsbGF4KCkge1xuICBsZXQgcmVsbGF4ID0gbmV3IFJlbGxheCgnLnJlbGxheCcsIHsgY2VudGVyOiB0cnVlIH0pO1xufVxuXG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cbiAgICBkZWZpbmUoW10sIGZhY3RvcnkpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgLy8gTm9kZS4gRG9lcyBub3Qgd29yayB3aXRoIHN0cmljdCBDb21tb25KUywgYnV0XG4gICAgLy8gb25seSBDb21tb25KUy1saWtlIGVudmlyb25tZW50cyB0aGF0IHN1cHBvcnQgbW9kdWxlLmV4cG9ydHMsXG4gICAgLy8gbGlrZSBOb2RlLlxuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICB9IGVsc2Uge1xuICAgIC8vIEJyb3dzZXIgZ2xvYmFscyAocm9vdCBpcyB3aW5kb3cpXG4gICAgcm9vdC5SZWxsYXggPSBmYWN0b3J5KCk7XG4gIH1cbn0odGhpcywgZnVuY3Rpb24gKCkge1xuICB2YXIgUmVsbGF4ID0gZnVuY3Rpb24oZWwsIG9wdGlvbnMpe1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIHNlbGYgPSBPYmplY3QuY3JlYXRlKFJlbGxheC5wcm90b3R5cGUpO1xuXG4gICAgdmFyIHBvc1kgPSAwO1xuICAgIHZhciBzY3JlZW5ZID0gMDtcbiAgICB2YXIgcG9zWCA9IDA7XG4gICAgdmFyIHNjcmVlblggPSAwO1xuICAgIHZhciBibG9ja3MgPSBbXTtcbiAgICB2YXIgcGF1c2UgPSB0cnVlO1xuXG4gICAgLy8gY2hlY2sgd2hhdCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgdG8gdXNlLCBhbmQgaWZcbiAgICAvLyBpdCdzIG5vdCBzdXBwb3J0ZWQsIHVzZSB0aGUgb25zY3JvbGwgZXZlbnRcbiAgICB2YXIgbG9vcCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgIHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgIHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgd2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgIGZ1bmN0aW9uKGNhbGxiYWNrKXsgc2V0VGltZW91dChjYWxsYmFjaywgMTAwMCAvIDYwKTsgfTtcblxuICAgIC8vIGNoZWNrIHdoaWNoIHRyYW5zZm9ybSBwcm9wZXJ0eSB0byB1c2VcbiAgICB2YXIgdHJhbnNmb3JtUHJvcCA9IHdpbmRvdy50cmFuc2Zvcm1Qcm9wIHx8IChmdW5jdGlvbigpe1xuICAgICAgICB2YXIgdGVzdEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGlmICh0ZXN0RWwuc3R5bGUudHJhbnNmb3JtID09PSBudWxsKSB7XG4gICAgICAgICAgdmFyIHZlbmRvcnMgPSBbJ1dlYmtpdCcsICdNb3onLCAnbXMnXTtcbiAgICAgICAgICBmb3IgKHZhciB2ZW5kb3IgaW4gdmVuZG9ycykge1xuICAgICAgICAgICAgaWYgKHRlc3RFbC5zdHlsZVsgdmVuZG9yc1t2ZW5kb3JdICsgJ1RyYW5zZm9ybScgXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiB2ZW5kb3JzW3ZlbmRvcl0gKyAnVHJhbnNmb3JtJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICd0cmFuc2Zvcm0nO1xuICAgICAgfSkoKTtcblxuICAgIC8vIERlZmF1bHQgU2V0dGluZ3NcbiAgICBzZWxmLm9wdGlvbnMgPSB7XG4gICAgICBzcGVlZDogLTIsXG4gICAgICBjZW50ZXI6IGZhbHNlLFxuICAgICAgd3JhcHBlcjogbnVsbCxcbiAgICAgIHJlbGF0aXZlVG9XcmFwcGVyOiBmYWxzZSxcbiAgICAgIHJvdW5kOiB0cnVlLFxuICAgICAgdmVydGljYWw6IHRydWUsXG4gICAgICBob3Jpem9udGFsOiBmYWxzZSxcbiAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbigpIHt9LFxuICAgIH07XG5cbiAgICAvLyBVc2VyIGRlZmluZWQgb3B0aW9ucyAobWlnaHQgaGF2ZSBtb3JlIGluIHRoZSBmdXR1cmUpXG4gICAgaWYgKG9wdGlvbnMpe1xuICAgICAgT2JqZWN0LmtleXMob3B0aW9ucykuZm9yRWFjaChmdW5jdGlvbihrZXkpe1xuICAgICAgICBzZWxmLm9wdGlvbnNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEJ5IGRlZmF1bHQsIHJlbGxheCBjbGFzc1xuICAgIGlmICghZWwpIHtcbiAgICAgIGVsID0gJy5yZWxsYXgnO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGlmIGVsIGlzIGEgY2xhc3NOYW1lIG9yIGEgbm9kZVxuICAgIHZhciBlbGVtZW50cyA9IHR5cGVvZiBlbCA9PT0gJ3N0cmluZycgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGVsKSA6IFtlbF07XG5cbiAgICAvLyBOb3cgcXVlcnkgc2VsZWN0b3JcbiAgICBpZiAoZWxlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgc2VsZi5lbGVtcyA9IGVsZW1lbnRzO1xuICAgIH1cblxuICAgIC8vIFRoZSBlbGVtZW50cyBkb24ndCBleGlzdFxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGVsZW1lbnRzIHlvdSdyZSB0cnlpbmcgdG8gc2VsZWN0IGRvbid0IGV4aXN0LlwiKTtcbiAgICB9XG5cbiAgICAvLyBIYXMgYSB3cmFwcGVyIGFuZCBpdCBleGlzdHNcbiAgICBpZiAoc2VsZi5vcHRpb25zLndyYXBwZXIpIHtcbiAgICAgIGlmICghc2VsZi5vcHRpb25zLndyYXBwZXIubm9kZVR5cGUpIHtcbiAgICAgICAgdmFyIHdyYXBwZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGYub3B0aW9ucy53cmFwcGVyKTtcblxuICAgICAgICBpZiAod3JhcHBlcikge1xuICAgICAgICAgIHNlbGYub3B0aW9ucy53cmFwcGVyID0gd3JhcHBlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgd3JhcHBlciB5b3UncmUgdHJ5aW5nIHRvIHVzZSBkb24ndCBleGlzdC5cIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cblxuICAgIC8vIEdldCBhbmQgY2FjaGUgaW5pdGlhbCBwb3NpdGlvbiBvZiBhbGwgZWxlbWVudHNcbiAgICB2YXIgY2FjaGVCbG9ja3MgPSBmdW5jdGlvbigpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5lbGVtcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBibG9jayA9IGNyZWF0ZUJsb2NrKHNlbGYuZWxlbXNbaV0pO1xuICAgICAgICBibG9ja3MucHVzaChibG9jayk7XG4gICAgICB9XG4gICAgfTtcblxuXG4gICAgLy8gTGV0J3Mga2ljayB0aGlzIHNjcmlwdCBvZmZcbiAgICAvLyBCdWlsZCBhcnJheSBmb3IgY2FjaGVkIGVsZW1lbnQgdmFsdWVzXG4gICAgdmFyIGluaXQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmxvY2tzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgc2VsZi5lbGVtc1tpXS5zdHlsZS5jc3NUZXh0ID0gYmxvY2tzW2ldLnN0eWxlO1xuICAgICAgfVxuXG4gICAgICBibG9ja3MgPSBbXTtcblxuICAgICAgc2NyZWVuWSA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICAgIHNjcmVlblggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgIHNldFBvc2l0aW9uKCk7XG5cbiAgICAgIGNhY2hlQmxvY2tzKCk7XG5cbiAgICAgIC8vIElmIHBhdXNlZCwgdW5wYXVzZSBhbmQgc2V0IGxpc3RlbmVyIGZvciB3aW5kb3cgcmVzaXppbmcgZXZlbnRzXG4gICAgICBpZiAocGF1c2UpIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGluaXQpO1xuICAgICAgICBwYXVzZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgYW5pbWF0ZSgpO1xuICAgIH07XG5cbiAgICAvLyBXZSB3YW50IHRvIGNhY2hlIHRoZSBwYXJhbGxheCBibG9ja3MnXG4gICAgLy8gdmFsdWVzOiBiYXNlLCB0b3AsIGhlaWdodCwgc3BlZWRcbiAgICAvLyBlbDogaXMgZG9tIG9iamVjdCwgcmV0dXJuOiBlbCBjYWNoZSB2YWx1ZXNcbiAgICB2YXIgY3JlYXRlQmxvY2sgPSBmdW5jdGlvbihlbCkge1xuICAgICAgdmFyIGRhdGFQZXJjZW50YWdlID0gZWwuZ2V0QXR0cmlidXRlKCAnZGF0YS1yZWxsYXgtcGVyY2VudGFnZScgKTtcbiAgICAgIHZhciBkYXRhU3BlZWQgPSBlbC5nZXRBdHRyaWJ1dGUoICdkYXRhLXJlbGxheC1zcGVlZCcgKTtcbiAgICAgIHZhciBkYXRhWmluZGV4ID0gZWwuZ2V0QXR0cmlidXRlKCAnZGF0YS1yZWxsYXgtemluZGV4JyApIHx8IDA7XG5cbiAgICAgIC8vIGluaXRpYWxpemluZyBhdCBzY3JvbGxZID0gMCAodG9wIG9mIGJyb3dzZXIpLCBzY3JvbGxYID0gMCAobGVmdCBvZiBicm93c2VyKVxuICAgICAgLy8gZW5zdXJlcyBlbGVtZW50cyBhcmUgcG9zaXRpb25lZCBiYXNlZCBvbiBIVE1MIGxheW91dC5cbiAgICAgIC8vXG4gICAgICAvLyBJZiB0aGUgZWxlbWVudCBoYXMgdGhlIHBlcmNlbnRhZ2UgYXR0cmlidXRlLCB0aGUgcG9zWSBhbmQgcG9zWCBuZWVkcyB0byBiZVxuICAgICAgLy8gdGhlIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uJ3MgdmFsdWUsIHNvIHRoYXQgdGhlIGVsZW1lbnRzIGFyZSBzdGlsbCBwb3NpdGlvbmVkIGJhc2VkIG9uIEhUTUwgbGF5b3V0XG4gICAgICB2YXIgd3JhcHBlclBvc1kgPSBzZWxmLm9wdGlvbnMud3JhcHBlciA/IHNlbGYub3B0aW9ucy53cmFwcGVyLnNjcm9sbFRvcCA6ICh3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCk7XG4gICAgICAvLyBJZiB0aGUgb3B0aW9uIHJlbGF0aXZlVG9XcmFwcGVyIGlzIHRydWUsIHVzZSB0aGUgd3JhcHBlcnMgb2Zmc2V0IHRvIHRvcCwgc3VidHJhY3RlZCBmcm9tIHRoZSBjdXJyZW50IHBhZ2Ugc2Nyb2xsLlxuICAgICAgaWYgKHNlbGYub3B0aW9ucy5yZWxhdGl2ZVRvV3JhcHBlcikge1xuICAgICAgICB2YXIgc2Nyb2xsUG9zWSA9ICh3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCk7XG4gICAgICAgIHdyYXBwZXJQb3NZID0gc2Nyb2xsUG9zWSAtIHNlbGYub3B0aW9ucy53cmFwcGVyLm9mZnNldFRvcDtcbiAgICAgIH1cbiAgICAgIHZhciBwb3NZID0gc2VsZi5vcHRpb25zLnZlcnRpY2FsID8gKCBkYXRhUGVyY2VudGFnZSB8fCBzZWxmLm9wdGlvbnMuY2VudGVyID8gd3JhcHBlclBvc1kgOiAwICkgOiAwO1xuICAgICAgdmFyIHBvc1ggPSBzZWxmLm9wdGlvbnMuaG9yaXpvbnRhbCA/ICggZGF0YVBlcmNlbnRhZ2UgfHwgc2VsZi5vcHRpb25zLmNlbnRlciA/ICh3aW5kb3cucGFnZVhPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0KSA6IDAgKSA6IDA7XG5cbiAgICAgIHZhciBibG9ja1RvcCA9IHBvc1kgKyBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XG4gICAgICB2YXIgYmxvY2tIZWlnaHQgPSBlbC5jbGllbnRIZWlnaHQgfHwgZWwub2Zmc2V0SGVpZ2h0IHx8IGVsLnNjcm9sbEhlaWdodDtcblxuICAgICAgdmFyIGJsb2NrTGVmdCA9IHBvc1ggKyBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuICAgICAgdmFyIGJsb2NrV2lkdGggPSBlbC5jbGllbnRXaWR0aCB8fCBlbC5vZmZzZXRXaWR0aCB8fCBlbC5zY3JvbGxXaWR0aDtcblxuICAgICAgLy8gYXBwYXJlbnRseSBwYXJhbGxheCBlcXVhdGlvbiBldmVyeW9uZSB1c2VzXG4gICAgICB2YXIgcGVyY2VudGFnZVkgPSBkYXRhUGVyY2VudGFnZSA/IGRhdGFQZXJjZW50YWdlIDogKHBvc1kgLSBibG9ja1RvcCArIHNjcmVlblkpIC8gKGJsb2NrSGVpZ2h0ICsgc2NyZWVuWSk7XG4gICAgICB2YXIgcGVyY2VudGFnZVggPSBkYXRhUGVyY2VudGFnZSA/IGRhdGFQZXJjZW50YWdlIDogKHBvc1ggLSBibG9ja0xlZnQgKyBzY3JlZW5YKSAvIChibG9ja1dpZHRoICsgc2NyZWVuWCk7XG4gICAgICBpZihzZWxmLm9wdGlvbnMuY2VudGVyKXsgcGVyY2VudGFnZVggPSAwLjU7IHBlcmNlbnRhZ2VZID0gMC41OyB9XG5cbiAgICAgIC8vIE9wdGlvbmFsIGluZGl2aWR1YWwgYmxvY2sgc3BlZWQgYXMgZGF0YSBhdHRyLCBvdGhlcndpc2UgZ2xvYmFsIHNwZWVkXG4gICAgICB2YXIgc3BlZWQgPSBkYXRhU3BlZWQgPyBkYXRhU3BlZWQgOiBzZWxmLm9wdGlvbnMuc3BlZWQ7XG5cbiAgICAgIHZhciBiYXNlcyA9IHVwZGF0ZVBvc2l0aW9uKHBlcmNlbnRhZ2VYLCBwZXJjZW50YWdlWSwgc3BlZWQpO1xuXG4gICAgICAvLyB+flN0b3JlIG5vbi10cmFuc2xhdGUzZCB0cmFuc2Zvcm1zfn5cbiAgICAgIC8vIFN0b3JlIGlubGluZSBzdHlsZXMgYW5kIGV4dHJhY3QgdHJhbnNmb3Jtc1xuICAgICAgdmFyIHN0eWxlID0gZWwuc3R5bGUuY3NzVGV4dDtcbiAgICAgIHZhciB0cmFuc2Zvcm0gPSAnJztcblxuICAgICAgLy8gQ2hlY2sgaWYgdGhlcmUncyBhbiBpbmxpbmUgc3R5bGVkIHRyYW5zZm9ybVxuICAgICAgaWYgKHN0eWxlLmluZGV4T2YoJ3RyYW5zZm9ybScpID49IDApIHtcbiAgICAgICAgLy8gR2V0IHRoZSBpbmRleCBvZiB0aGUgdHJhbnNmb3JtXG4gICAgICAgIHZhciBpbmRleCA9IHN0eWxlLmluZGV4T2YoJ3RyYW5zZm9ybScpO1xuXG4gICAgICAgIC8vIFRyaW0gdGhlIHN0eWxlIHRvIHRoZSB0cmFuc2Zvcm0gcG9pbnQgYW5kIGdldCB0aGUgZm9sbG93aW5nIHNlbWktY29sb24gaW5kZXhcbiAgICAgICAgdmFyIHRyaW1tZWRTdHlsZSA9IHN0eWxlLnNsaWNlKGluZGV4KTtcbiAgICAgICAgdmFyIGRlbGltaXRlciA9IHRyaW1tZWRTdHlsZS5pbmRleE9mKCc7Jyk7XG5cbiAgICAgICAgLy8gUmVtb3ZlIFwidHJhbnNmb3JtXCIgc3RyaW5nIGFuZCBzYXZlIHRoZSBhdHRyaWJ1dGVcbiAgICAgICAgaWYgKGRlbGltaXRlcikge1xuICAgICAgICAgIHRyYW5zZm9ybSA9IFwiIFwiICsgdHJpbW1lZFN0eWxlLnNsaWNlKDExLCBkZWxpbWl0ZXIpLnJlcGxhY2UoL1xccy9nLCcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cmFuc2Zvcm0gPSBcIiBcIiArIHRyaW1tZWRTdHlsZS5zbGljZSgxMSkucmVwbGFjZSgvXFxzL2csJycpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJhc2VYOiBiYXNlcy54LFxuICAgICAgICBiYXNlWTogYmFzZXMueSxcbiAgICAgICAgdG9wOiBibG9ja1RvcCxcbiAgICAgICAgbGVmdDogYmxvY2tMZWZ0LFxuICAgICAgICBoZWlnaHQ6IGJsb2NrSGVpZ2h0LFxuICAgICAgICB3aWR0aDogYmxvY2tXaWR0aCxcbiAgICAgICAgc3BlZWQ6IHNwZWVkLFxuICAgICAgICBzdHlsZTogc3R5bGUsXG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtLFxuICAgICAgICB6aW5kZXg6IGRhdGFaaW5kZXhcbiAgICAgIH07XG4gICAgfTtcblxuICAgIC8vIHNldCBzY3JvbGwgcG9zaXRpb24gKHBvc1ksIHBvc1gpXG4gICAgLy8gc2lkZSBlZmZlY3QgbWV0aG9kIGlzIG5vdCBpZGVhbCwgYnV0IG9rYXkgZm9yIG5vd1xuICAgIC8vIHJldHVybnMgdHJ1ZSBpZiB0aGUgc2Nyb2xsIGNoYW5nZWQsIGZhbHNlIGlmIG5vdGhpbmcgaGFwcGVuZWRcbiAgICB2YXIgc2V0UG9zaXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvbGRZID0gcG9zWTtcbiAgICAgIHZhciBvbGRYID0gcG9zWDtcblxuICAgICAgcG9zWSA9IHNlbGYub3B0aW9ucy53cmFwcGVyID8gc2VsZi5vcHRpb25zLndyYXBwZXIuc2Nyb2xsVG9wIDogKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCB8fCBkb2N1bWVudC5ib2R5LnBhcmVudE5vZGUgfHwgZG9jdW1lbnQuYm9keSkuc2Nyb2xsVG9wIHx8IHdpbmRvdy5wYWdlWU9mZnNldDtcbiAgICAgIHBvc1ggPSBzZWxmLm9wdGlvbnMud3JhcHBlciA/IHNlbGYub3B0aW9ucy53cmFwcGVyLnNjcm9sbExlZnQgOiAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IHx8IGRvY3VtZW50LmJvZHkucGFyZW50Tm9kZSB8fCBkb2N1bWVudC5ib2R5KS5zY3JvbGxMZWZ0IHx8IHdpbmRvdy5wYWdlWE9mZnNldDtcbiAgICAgIC8vIElmIG9wdGlvbiByZWxhdGl2ZVRvV3JhcHBlciBpcyB0cnVlLCB1c2UgcmVsYXRpdmUgd3JhcHBlciB2YWx1ZSBpbnN0ZWFkLlxuICAgICAgaWYgKHNlbGYub3B0aW9ucy5yZWxhdGl2ZVRvV3JhcHBlcikge1xuICAgICAgICB2YXIgc2Nyb2xsUG9zWSA9IChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgfHwgZG9jdW1lbnQuYm9keS5wYXJlbnROb2RlIHx8IGRvY3VtZW50LmJvZHkpLnNjcm9sbFRvcCB8fCB3aW5kb3cucGFnZVlPZmZzZXQ7XG4gICAgICAgIHBvc1kgPSBzY3JvbGxQb3NZIC0gc2VsZi5vcHRpb25zLndyYXBwZXIub2Zmc2V0VG9wO1xuICAgICAgfVxuXG5cbiAgICAgIGlmIChvbGRZICE9IHBvc1kgJiYgc2VsZi5vcHRpb25zLnZlcnRpY2FsKSB7XG4gICAgICAgIC8vIHNjcm9sbCBjaGFuZ2VkLCByZXR1cm4gdHJ1ZVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9sZFggIT0gcG9zWCAmJiBzZWxmLm9wdGlvbnMuaG9yaXpvbnRhbCkge1xuICAgICAgICAvLyBzY3JvbGwgY2hhbmdlZCwgcmV0dXJuIHRydWVcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIHNjcm9sbCBkaWQgbm90IGNoYW5nZVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvLyBBaGggYSBwdXJlIGZ1bmN0aW9uLCBnZXRzIG5ldyB0cmFuc2Zvcm0gdmFsdWVcbiAgICAvLyBiYXNlZCBvbiBzY3JvbGxQb3NpdGlvbiBhbmQgc3BlZWRcbiAgICAvLyBBbGxvdyBmb3IgZGVjaW1hbCBwaXhlbCB2YWx1ZXNcbiAgICB2YXIgdXBkYXRlUG9zaXRpb24gPSBmdW5jdGlvbihwZXJjZW50YWdlWCwgcGVyY2VudGFnZVksIHNwZWVkKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICB2YXIgdmFsdWVYID0gKHNwZWVkICogKDEwMCAqICgxIC0gcGVyY2VudGFnZVgpKSk7XG4gICAgICB2YXIgdmFsdWVZID0gKHNwZWVkICogKDEwMCAqICgxIC0gcGVyY2VudGFnZVkpKSk7XG5cbiAgICAgIHJlc3VsdC54ID0gc2VsZi5vcHRpb25zLnJvdW5kID8gTWF0aC5yb3VuZCh2YWx1ZVgpIDogTWF0aC5yb3VuZCh2YWx1ZVggKiAxMDApIC8gMTAwO1xuICAgICAgcmVzdWx0LnkgPSBzZWxmLm9wdGlvbnMucm91bmQgPyBNYXRoLnJvdW5kKHZhbHVlWSkgOiBNYXRoLnJvdW5kKHZhbHVlWSAqIDEwMCkgLyAxMDA7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIC8vIExvb3BcbiAgICB2YXIgdXBkYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoc2V0UG9zaXRpb24oKSAmJiBwYXVzZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYW5pbWF0ZSgpO1xuICAgICAgfVxuXG4gICAgICAvLyBsb29wIGFnYWluXG4gICAgICBsb29wKHVwZGF0ZSk7XG4gICAgfTtcblxuICAgIC8vIFRyYW5zZm9ybTNkIG9uIHBhcmFsbGF4IGVsZW1lbnRcbiAgICB2YXIgYW5pbWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBvc2l0aW9ucztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5lbGVtcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBwZXJjZW50YWdlWSA9ICgocG9zWSAtIGJsb2Nrc1tpXS50b3AgKyBzY3JlZW5ZKSAvIChibG9ja3NbaV0uaGVpZ2h0ICsgc2NyZWVuWSkpO1xuICAgICAgICB2YXIgcGVyY2VudGFnZVggPSAoKHBvc1ggLSBibG9ja3NbaV0ubGVmdCArIHNjcmVlblgpIC8gKGJsb2Nrc1tpXS53aWR0aCArIHNjcmVlblgpKTtcblxuICAgICAgICAvLyBTdWJ0cmFjdGluZyBpbml0aWFsaXplIHZhbHVlLCBzbyBlbGVtZW50IHN0YXlzIGluIHNhbWUgc3BvdCBhcyBIVE1MXG4gICAgICAgIHBvc2l0aW9ucyA9IHVwZGF0ZVBvc2l0aW9uKHBlcmNlbnRhZ2VYLCBwZXJjZW50YWdlWSwgYmxvY2tzW2ldLnNwZWVkKTsvLyAtIGJsb2Nrc1tpXS5iYXNlWDtcbiAgICAgICAgdmFyIHBvc2l0aW9uWSA9IHBvc2l0aW9ucy55IC0gYmxvY2tzW2ldLmJhc2VZO1xuICAgICAgICB2YXIgcG9zaXRpb25YID0gcG9zaXRpb25zLnggLSBibG9ja3NbaV0uYmFzZVg7XG5cbiAgICAgICAgdmFyIHppbmRleCA9IGJsb2Nrc1tpXS56aW5kZXg7XG5cbiAgICAgICAgLy8gTW92ZSB0aGF0IGVsZW1lbnRcbiAgICAgICAgLy8gKFNldCB0aGUgbmV3IHRyYW5zbGF0aW9uIGFuZCBhcHBlbmQgaW5pdGlhbCBpbmxpbmUgdHJhbnNmb3Jtcy4pXG4gICAgICAgIHZhciB0cmFuc2xhdGUgPSAndHJhbnNsYXRlM2QoJyArIChzZWxmLm9wdGlvbnMuaG9yaXpvbnRhbCA/IHBvc2l0aW9uWCA6ICcwJykgKyAncHgsJyArIChzZWxmLm9wdGlvbnMudmVydGljYWwgPyBwb3NpdGlvblkgOiAnMCcpICsgJ3B4LCcgKyB6aW5kZXggKyAncHgpICcgKyBibG9ja3NbaV0udHJhbnNmb3JtO1xuICAgICAgICBzZWxmLmVsZW1zW2ldLnN0eWxlW3RyYW5zZm9ybVByb3BdID0gdHJhbnNsYXRlO1xuICAgICAgfVxuICAgICAgc2VsZi5vcHRpb25zLmNhbGxiYWNrKHBvc2l0aW9ucyk7XG4gICAgfTtcblxuICAgIHNlbGYuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLmVsZW1zLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgc2VsZi5lbGVtc1tpXS5zdHlsZS5jc3NUZXh0ID0gYmxvY2tzW2ldLnN0eWxlO1xuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgcmVzaXplIGV2ZW50IGxpc3RlbmVyIGlmIG5vdCBwYXVzZSwgYW5kIHBhdXNlXG4gICAgICBpZiAoIXBhdXNlKSB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBpbml0KTtcbiAgICAgICAgcGF1c2UgPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBJbml0XG4gICAgaW5pdCgpO1xuXG4gICAgLy8gU3RhcnQgdGhlIGxvb3BcbiAgICB1cGRhdGUoKTtcblxuICAgIC8vIEFsbG93IHRvIHJlY2FsY3VsYXRlIHRoZSBpbml0aWFsIHZhbHVlcyB3aGVuZXZlciB3ZSB3YW50XG4gICAgc2VsZi5yZWZyZXNoID0gaW5pdDtcblxuICAgIHJldHVybiBzZWxmO1xuICB9O1xuICByZXR1cm4gUmVsbGF4O1xufSkpOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/js/rellax.js\n')},"./src/js/smoothScroll.js":/*!********************************!*\
  !*** ./src/js/smoothScroll.js ***!
  \********************************//*! no static exports found */function(module,exports,__webpack_require__){'use strict';eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n// This function is mostly copy/pasted from:\n// https://pawelgrzybek.com/page-scroll-in-vanilla-javascript/\n/* eslint-disable */\nfunction smoothScroll(destination) {\n  var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 200;\n  var easing = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \'linear\';\n  var callback = arguments[3];\n\n\n  var easings = {\n    linear: function linear(t) {\n      return t;\n    },\n    easeOutQuint: function easeOutQuint(t) {\n      return 1 + --t * t * t * t * t;\n    }\n  };\n\n  var start = window.pageYOffset;\n  var startTime = \'now\' in window.performance ? performance.now() : new Date().getTime();\n\n  var documentHeight = Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight);\n  var windowHeight = window.innerHeight || document.documentElement.clientHeight || document.getElementsByTagName(\'body\')[0].clientHeight;\n  var destinationOffset = typeof destination === \'number\' ? destination : destination.offsetTop;\n  var destinationOffsetToScroll = Math.round(documentHeight - destinationOffset < windowHeight ? documentHeight - windowHeight : destinationOffset);\n\n  if (\'requestAnimationFrame\' in window === false) {\n    window.scroll(0, destinationOffsetToScroll);\n    if (callback) {\n      callback();\n    }\n    return;\n  }\n\n  function scroll() {\n    var now = \'now\' in window.performance ? performance.now() : new Date().getTime();\n    var time = Math.min(1, (now - startTime) / duration);\n    var timeFunction = easings[easing](time);\n    window.scroll(0, Math.ceil(timeFunction * (destinationOffsetToScroll - start) + start));\n\n    if (window.pageYOffset === destinationOffsetToScroll) {\n      if (callback) {\n        callback();\n      }\n      return;\n    }\n\n    requestAnimationFrame(scroll);\n  }\n\n  scroll();\n}\n\nexports.default = smoothScroll;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvc21vb3RoU2Nyb2xsLmpzPzU5Y2MiXSwibmFtZXMiOlsic21vb3RoU2Nyb2xsIiwiZGVzdGluYXRpb24iLCJkdXJhdGlvbiIsImVhc2luZyIsImNhbGxiYWNrIiwiZWFzaW5ncyIsImxpbmVhciIsInQiLCJlYXNlT3V0UXVpbnQiLCJzdGFydCIsIndpbmRvdyIsInBhZ2VZT2Zmc2V0Iiwic3RhcnRUaW1lIiwicGVyZm9ybWFuY2UiLCJub3ciLCJEYXRlIiwiZ2V0VGltZSIsImRvY3VtZW50SGVpZ2h0IiwiTWF0aCIsIm1heCIsImRvY3VtZW50IiwiYm9keSIsInNjcm9sbEhlaWdodCIsIm9mZnNldEhlaWdodCIsImRvY3VtZW50RWxlbWVudCIsImNsaWVudEhlaWdodCIsIndpbmRvd0hlaWdodCIsImlubmVySGVpZ2h0IiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJkZXN0aW5hdGlvbk9mZnNldCIsIm9mZnNldFRvcCIsImRlc3RpbmF0aW9uT2Zmc2V0VG9TY3JvbGwiLCJyb3VuZCIsInNjcm9sbCIsInRpbWUiLCJtaW4iLCJ0aW1lRnVuY3Rpb24iLCJjZWlsIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIl0sIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBLFNBQVNBLFlBQVQsQ0FBc0JDLFdBQXRCLEVBQWdGO0FBQUEsTUFBN0NDLFFBQTZDLHVFQUFsQyxHQUFrQztBQUFBLE1BQTdCQyxNQUE2Qix1RUFBcEIsUUFBb0I7QUFBQSxNQUFWQyxRQUFVOzs7QUFFOUUsTUFBTUMsVUFBVTtBQUNkQyxVQURjLGtCQUNQQyxDQURPLEVBQ0o7QUFDUixhQUFPQSxDQUFQO0FBQ0QsS0FIYTtBQUlkQyxnQkFKYyx3QkFJREQsQ0FKQyxFQUlFO0FBQ2QsYUFBTyxJQUFLLEVBQUVBLENBQUgsR0FBUUEsQ0FBUixHQUFZQSxDQUFaLEdBQWdCQSxDQUFoQixHQUFvQkEsQ0FBL0I7QUFDRDtBQU5hLEdBQWhCOztBQVNBLE1BQU1FLFFBQVFDLE9BQU9DLFdBQXJCO0FBQ0EsTUFBTUMsWUFBWSxTQUFTRixPQUFPRyxXQUFoQixHQUE4QkEsWUFBWUMsR0FBWixFQUE5QixHQUFrRCxJQUFJQyxJQUFKLEdBQVdDLE9BQVgsRUFBcEU7O0FBRUEsTUFBTUMsaUJBQWlCQyxLQUFLQyxHQUFMLENBQVNDLFNBQVNDLElBQVQsQ0FBY0MsWUFBdkIsRUFBcUNGLFNBQVNDLElBQVQsQ0FBY0UsWUFBbkQsRUFBaUVILFNBQVNJLGVBQVQsQ0FBeUJDLFlBQTFGLEVBQXdHTCxTQUFTSSxlQUFULENBQXlCRixZQUFqSSxFQUErSUYsU0FBU0ksZUFBVCxDQUF5QkQsWUFBeEssQ0FBdkI7QUFDQSxNQUFNRyxlQUFlaEIsT0FBT2lCLFdBQVAsSUFBc0JQLFNBQVNJLGVBQVQsQ0FBeUJDLFlBQS9DLElBQStETCxTQUFTUSxvQkFBVCxDQUE4QixNQUE5QixFQUFzQyxDQUF0QyxFQUF5Q0gsWUFBN0g7QUFDQSxNQUFNSSxvQkFBb0IsT0FBTzVCLFdBQVAsS0FBdUIsUUFBdkIsR0FBa0NBLFdBQWxDLEdBQWdEQSxZQUFZNkIsU0FBdEY7QUFDQSxNQUFNQyw0QkFBNEJiLEtBQUtjLEtBQUwsQ0FBV2YsaUJBQWlCWSxpQkFBakIsR0FBcUNILFlBQXJDLEdBQW9EVCxpQkFBaUJTLFlBQXJFLEdBQW9GRyxpQkFBL0YsQ0FBbEM7O0FBRUEsTUFBSSwyQkFBMkJuQixNQUEzQixLQUFzQyxLQUExQyxFQUFpRDtBQUMvQ0EsV0FBT3VCLE1BQVAsQ0FBYyxDQUFkLEVBQWlCRix5QkFBakI7QUFDQSxRQUFJM0IsUUFBSixFQUFjO0FBQ1pBO0FBQ0Q7QUFDRDtBQUNEOztBQUVELFdBQVM2QixNQUFULEdBQWtCO0FBQ2hCLFFBQU1uQixNQUFNLFNBQVNKLE9BQU9HLFdBQWhCLEdBQThCQSxZQUFZQyxHQUFaLEVBQTlCLEdBQWtELElBQUlDLElBQUosR0FBV0MsT0FBWCxFQUE5RDtBQUNBLFFBQU1rQixPQUFPaEIsS0FBS2lCLEdBQUwsQ0FBUyxDQUFULEVBQWEsQ0FBQ3JCLE1BQU1GLFNBQVAsSUFBb0JWLFFBQWpDLENBQWI7QUFDQSxRQUFNa0MsZUFBZS9CLFFBQVFGLE1BQVIsRUFBZ0IrQixJQUFoQixDQUFyQjtBQUNBeEIsV0FBT3VCLE1BQVAsQ0FBYyxDQUFkLEVBQWlCZixLQUFLbUIsSUFBTCxDQUFXRCxnQkFBZ0JMLDRCQUE0QnRCLEtBQTVDLENBQUQsR0FBdURBLEtBQWpFLENBQWpCOztBQUVBLFFBQUlDLE9BQU9DLFdBQVAsS0FBdUJvQix5QkFBM0IsRUFBc0Q7QUFDcEQsVUFBSTNCLFFBQUosRUFBYztBQUNaQTtBQUNEO0FBQ0Q7QUFDRDs7QUFFRGtDLDBCQUFzQkwsTUFBdEI7QUFDRDs7QUFFREE7QUFDRDs7a0JBRWNqQyxZIiwiZmlsZSI6Ii4vc3JjL2pzL3Ntb290aFNjcm9sbC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIFRoaXMgZnVuY3Rpb24gaXMgbW9zdGx5IGNvcHkvcGFzdGVkIGZyb206XG4vLyBodHRwczovL3Bhd2VsZ3J6eWJlay5jb20vcGFnZS1zY3JvbGwtaW4tdmFuaWxsYS1qYXZhc2NyaXB0L1xuLyogZXNsaW50LWRpc2FibGUgKi9cbmZ1bmN0aW9uIHNtb290aFNjcm9sbChkZXN0aW5hdGlvbiwgZHVyYXRpb24gPSAyMDAsIGVhc2luZyA9ICdsaW5lYXInLCBjYWxsYmFjaykge1xuXG4gIGNvbnN0IGVhc2luZ3MgPSB7XG4gICAgbGluZWFyKHQpIHtcbiAgICAgIHJldHVybiB0O1xuICAgIH0sXG4gICAgZWFzZU91dFF1aW50KHQpIHtcbiAgICAgIHJldHVybiAxICsgKC0tdCkgKiB0ICogdCAqIHQgKiB0O1xuICAgIH0sXG4gIH07XG5cbiAgY29uc3Qgc3RhcnQgPSB3aW5kb3cucGFnZVlPZmZzZXQ7XG4gIGNvbnN0IHN0YXJ0VGltZSA9ICdub3cnIGluIHdpbmRvdy5wZXJmb3JtYW5jZSA/IHBlcmZvcm1hbmNlLm5vdygpIDogbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cbiAgY29uc3QgZG9jdW1lbnRIZWlnaHQgPSBNYXRoLm1heChkb2N1bWVudC5ib2R5LnNjcm9sbEhlaWdodCwgZG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHQsIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQsIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQsIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5vZmZzZXRIZWlnaHQpO1xuICBjb25zdCB3aW5kb3dIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYm9keScpWzBdLmNsaWVudEhlaWdodDtcbiAgY29uc3QgZGVzdGluYXRpb25PZmZzZXQgPSB0eXBlb2YgZGVzdGluYXRpb24gPT09ICdudW1iZXInID8gZGVzdGluYXRpb24gOiBkZXN0aW5hdGlvbi5vZmZzZXRUb3A7XG4gIGNvbnN0IGRlc3RpbmF0aW9uT2Zmc2V0VG9TY3JvbGwgPSBNYXRoLnJvdW5kKGRvY3VtZW50SGVpZ2h0IC0gZGVzdGluYXRpb25PZmZzZXQgPCB3aW5kb3dIZWlnaHQgPyBkb2N1bWVudEhlaWdodCAtIHdpbmRvd0hlaWdodCA6IGRlc3RpbmF0aW9uT2Zmc2V0KTtcblxuICBpZiAoJ3JlcXVlc3RBbmltYXRpb25GcmFtZScgaW4gd2luZG93ID09PSBmYWxzZSkge1xuICAgIHdpbmRvdy5zY3JvbGwoMCwgZGVzdGluYXRpb25PZmZzZXRUb1Njcm9sbCk7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICBmdW5jdGlvbiBzY3JvbGwoKSB7XG4gICAgY29uc3Qgbm93ID0gJ25vdycgaW4gd2luZG93LnBlcmZvcm1hbmNlID8gcGVyZm9ybWFuY2Uubm93KCkgOiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICBjb25zdCB0aW1lID0gTWF0aC5taW4oMSwgKChub3cgLSBzdGFydFRpbWUpIC8gZHVyYXRpb24pKTtcbiAgICBjb25zdCB0aW1lRnVuY3Rpb24gPSBlYXNpbmdzW2Vhc2luZ10odGltZSk7XG4gICAgd2luZG93LnNjcm9sbCgwLCBNYXRoLmNlaWwoKHRpbWVGdW5jdGlvbiAqIChkZXN0aW5hdGlvbk9mZnNldFRvU2Nyb2xsIC0gc3RhcnQpKSArIHN0YXJ0KSk7XG5cbiAgICBpZiAod2luZG93LnBhZ2VZT2Zmc2V0ID09PSBkZXN0aW5hdGlvbk9mZnNldFRvU2Nyb2xsKSB7XG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc2Nyb2xsKTtcbiAgfVxuXG4gIHNjcm9sbCgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzbW9vdGhTY3JvbGw7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/js/smoothScroll.js\n')}});