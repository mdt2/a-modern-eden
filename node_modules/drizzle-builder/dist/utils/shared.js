'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isCollection = exports.isPattern = exports.isPage = exports.isType = exports.titleCase = exports.resourcePath = exports.relativePathArray = exports.keyname = exports.idKeys = undefined;

var _path = require('path');

var path = _interopRequireDefault(_path).default;

var _ramda = require('ramda');

var R = _interopRequireDefault(_ramda).default;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Split a string on a common separator.
 * @param {String} idString
 * @return {Array}
 */
function idKeys(idString) {
  return idString.split('.');
}

/**
 * Utility function to process strings to make them key-like (for properties).
 * Previously this stripped prefixed numbers, etc., but for now it is
 * dead simple.
 */
function keyname(str) {
  return path.basename(path.normalize(str), path.extname(str));
}

/**
 * Given a file's path and a string representing a directory name,
 * return an Array that only contains directories at or beneath that
 * directory.
 *
 * @example relativePathArray('/foo/bar/baz/ding/dong/tink.txt', 'baz')
 *  // -> ['baz', 'ding', 'dong']
 * @param {String} filePath
 * @param {String} fromPath
 * @return {Array}
 */
function relativePathArray(filePath, fromPath) {
  filePath = path.normalize(filePath);
  fromPath = path.normalize(fromPath);
  if (filePath.indexOf(fromPath) === -1 || filePath === fromPath) {
    // TODO Error handling: this should cause a warn
    return [];
  }
  var keys = path.relative(fromPath, path.dirname(filePath));
  if (keys && keys.length) {
    return keys.split(path.sep);
  }
  return [];
}

/**
 * Generate a path for a resource based on its ID.
 * @param {String} resourceId   '.'-separated ID for this resource
 * @param {String} dest         This path will be prepended
 * @return {String} path
 */
function resourcePath(resourceId) {
  var dest = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

  var subPath = idKeys(resourceId);
  // Remove first item because it is the "resource type"
  // If there _is_ only one item in the ID, it will be left alone
  // To serve as the filename.
  if (subPath.length && subPath.length > 1) {
    subPath.shift();
  }
  var filename = subPath.pop() + '.html';
  var outputPath = path.normalize(path.join(dest, subPath.join(path.sep), filename));
  return outputPath;
}

/**
 * Convert str to title case (every word will be capitalized)
 * @param {String} str
 * @return {String}
 */
function titleCase(str) {
  return str.toLowerCase().replace(/(\-|_)/g, ' ').replace(/\w\S*/g, function (word) {
    return word.charAt(0).toUpperCase() + word.substr(1);
  });
}

/**
 * Resource type logic.
 */
var isType = R.propEq('resourceType');
var isPage = isType('page');
var isPattern = isType('pattern');
var isCollection = isType('collection');

exports.idKeys = idKeys;
exports.keyname = keyname;
exports.relativePathArray = relativePathArray;
exports.resourcePath = resourcePath;
exports.titleCase = titleCase;
exports.isType = isType;
exports.isPage = isPage;
exports.isPattern = isPattern;
exports.isCollection = isCollection;